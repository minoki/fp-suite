-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/minoki/haskell-floating-point/tree/master/fp-ieee#readme</a>
@package fp-ieee
@version 0.1.0.0

module Numeric.Floating.IEEE.Internal

-- | <tt><a>truncate</a> x</tt> returns the integer nearest <tt>x</tt>
--   between zero and <tt>x</tt>
truncate :: (RealFrac a, Integral b) => a -> b

-- | <tt><a>round</a> x</tt> returns the nearest integer to <tt>x</tt>; the
--   even integer if <tt>x</tt> is equidistant between two integers
round :: (RealFrac a, Integral b) => a -> b

-- | <tt><a>ceiling</a> x</tt> returns the least integer not less than
--   <tt>x</tt>
ceiling :: (RealFrac a, Integral b) => a -> b

-- | <tt><a>floor</a> x</tt> returns the greatest integer not greater than
--   <tt>x</tt>
floor :: (RealFrac a, Integral b) => a -> b
isFloatBinary32 :: Bool
isDoubleBinary64 :: Bool

-- | <pre>
--   &gt;&gt;&gt; (minPositive :: Float) == 0x1p-149
--   True
--   
--   &gt;&gt;&gt; (minPositive :: Double) == 0x1p-1074
--   True
--   
--   &gt;&gt;&gt; nextDown (minPositive :: Float)
--   0.0
--   
--   &gt;&gt;&gt; nextDown (minPositive :: Double)
--   0.0
--   </pre>
minPositive :: RealFloat a => a

-- | <pre>
--   &gt;&gt;&gt; (minPositiveNormal :: Float) == 0x1p-126
--   True
--   
--   &gt;&gt;&gt; (minPositiveNormal :: Double) == 0x1p-1022
--   True
--   
--   &gt;&gt;&gt; isDenormalized (minPositiveNormal :: Float)
--   False
--   
--   &gt;&gt;&gt; isDenormalized (minPositiveNormal :: Double)
--   False
--   
--   &gt;&gt;&gt; isDenormalized (nextDown (minPositiveNormal :: Float))
--   True
--   
--   &gt;&gt;&gt; isDenormalized (nextDown (minPositiveNormal :: Double))
--   True
--   </pre>
minPositiveNormal :: RealFloat a => a

-- | <pre>
--   &gt;&gt;&gt; (maxFinite :: Float) == 0x1.fffffep+127
--   True
--   
--   &gt;&gt;&gt; (maxFinite :: Double) == 0x1.ffff_ffff_ffff_fp+1023
--   True
--   </pre>
maxFinite :: RealFloat a => a

-- | <pre>
--   &gt;&gt;&gt; negateIntAsWord minBound == fromInteger (negate (fromIntegral (minBound :: Int)))
--   True
--   </pre>
negateIntAsWord :: Int -> Word

-- | <pre>
--   &gt;&gt;&gt; absIntAsWord minBound == fromInteger (abs (fromIntegral (minBound :: Int)))
--   True
--   </pre>
absIntAsWord :: Int -> Word
data Class
SignalingNaN :: Class
QuietNaN :: Class
NegativeInfinity :: Class
NegativeNormal :: Class
NegativeSubnormal :: Class
NegativeZero :: Class
PositiveZero :: Class
PositiveSubnormal :: Class
PositiveNormal :: Class
PositiveInfinity :: Class

-- | IEEE 754 <tt>isNormal</tt> operation.
isNormal :: RealFloat a => a -> Bool
isFloatNormal :: Float -> Bool
isDoubleNormal :: Double -> Bool

-- | IEEE 754 <tt>isFinite</tt> operation.
isFinite :: RealFloat a => a -> Bool

-- | IEEE 754 <tt>isZero</tt> operation.
isZero :: RealFloat a => a -> Bool

-- | IEEE 754 <tt>isSignMinus</tt> operation.
--   
--   Since <a>RealFloat</a> constraint is insufficient to query the sign of
--   NaNs, this function treats all NaNs as positive.
isSignMinus :: RealFloat a => a -> Bool

-- | Comparison with IEEE 754 <tt>totalOrder</tt> predicate.
--   
--   Since <a>RealFloat</a> constraint is insufficient to query the sign
--   and payload of NaNs, this function treats all NaNs as positive.
--   
--   Floating-point numbers are ordered as, &lt;math&gt;.
compareByTotalOrder :: RealFloat a => a -> a -> Ordering

-- | Comparison with IEEE 754 <tt>totalOrderMag</tt> predicate.
compareByTotalOrderMag :: RealFloat a => a -> a -> Ordering

-- | Treats NaNs as quiet
classify :: RealFloat a => a -> Class
classifyFloat :: Float -> Class
classifyDouble :: Double -> Class
canonicalizeDouble :: Double -> Double
canonicalizeFloat :: Float -> Float

-- | Similar to <a>realToFrac</a>, but treats NaN, infinities, negative
--   zero even if the rewrite rule is off.
realFloatToFrac :: (RealFloat a, Fractional b) => a -> b
canonicalize :: RealFloat a => a -> a
integerToIntMaybe :: Integer -> Maybe Int
naturalToWordMaybe :: Natural -> Maybe Word
unsafeShiftLInteger :: Integer -> Int -> Integer
unsafeShiftRInteger :: Integer -> Int -> Integer

-- | <a>Integer</a> version of <a>countTrailingZeros</a>. The argument must
--   not be zero.
--   
--   <pre>
--   \(NonZero x) -&gt; countTrailingZerosInteger (toInteger x) === countTrailingZeros (x :: Int64)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; countTrailingZerosInteger 7
--   0
--   
--   &gt;&gt;&gt; countTrailingZerosInteger 8
--   3
--   </pre>
countTrailingZerosInteger :: Integer -> Int

-- | Assumption: <tt>n &gt; 0</tt>, <tt>e &gt;= 0</tt>, and <tt>integerLog2
--   n &gt;= e</tt>
--   
--   Returns <tt>compare (n `<a>rem</a>` 2^(e+1)) (2^e)</tt>.
roundingMode :: Integer -> Int -> Ordering

-- | Returns <tt>Just (integerLog2 x)</tt> if the argument <tt>x</tt> is a
--   power of 2, and <tt>Nothing</tt> otherwise. The argument <tt>x</tt>
--   must be strictly positive.
integerIsPowerOf2 :: Integer -> Maybe Int

-- | Returns <tt>(integerLog2 x, isJust (integerIsPowerOf2 x))</tt>. The
--   argument <tt>x</tt> must be strictly positive.
integerLog2IsPowerOf2 :: Integer -> (Int, Bool)

-- | IEEE 754 <tt>minimum</tt> operation. <tt>-0</tt> is smaller than
--   <tt>+0</tt>. Propagates NaNs.
minimum' :: RealFloat a => a -> a -> a

-- | IEEE 754 <tt>minimumNumber</tt> operation. <tt>-0</tt> is smaller than
--   <tt>+0</tt>. Treats NaNs as missing data.
minimumNumber :: RealFloat a => a -> a -> a

-- | IEEE 754 <tt>maximum</tt> operation. <tt>-0</tt> is smaller than
--   <tt>+0</tt>. Propagates NaNs.
maximum' :: RealFloat a => a -> a -> a

-- | IEEE 754 <tt>maximumNumber</tt> operation. <tt>-0</tt> is smaller than
--   <tt>+0</tt>. Treats NaNs as missing data.
maximumNumber :: RealFloat a => a -> a -> a

-- | IEEE 754 <tt>minimumMagnitude</tt> operation.
minimumMagnitude :: RealFloat a => a -> a -> a

-- | IEEE 754 <tt>minimumMagnitudeNumber</tt> operation.
minimumMagnitudeNumber :: RealFloat a => a -> a -> a

-- | IEEE 754 <tt>maximumMagnitude</tt> operation.
maximumMagnitude :: RealFloat a => a -> a -> a

-- | IEEE 754 <tt>maximumMagnitudeNumber</tt> operation.
maximumMagnitudeNumber :: RealFloat a => a -> a -> a
minimumFloat :: Float -> Float -> Float
minimumDouble :: Double -> Double -> Double
minimumNumberFloat :: Float -> Float -> Float
minimumNumberDouble :: Double -> Double -> Double
maximumFloat :: Float -> Float -> Float
maximumDouble :: Double -> Double -> Double
maximumNumberFloat :: Float -> Float -> Float
maximumNumberDouble :: Double -> Double -> Double

-- | IEEE 754 <tt>nextUp</tt> operation.
--   
--   <pre>
--   &gt;&gt;&gt; nextUp 1 == (0x1.000002p0 :: Float)
--   True
--   
--   &gt;&gt;&gt; nextUp 1 == (0x1.0000_0000_0000_1p0 :: Double)
--   True
--   
--   &gt;&gt;&gt; nextUp (1/0) == (1/0 :: Double)
--   True
--   
--   &gt;&gt;&gt; nextUp (-1/0) == (- maxFinite :: Double)
--   True
--   
--   &gt;&gt;&gt; nextUp 0 == (0x1p-1074 :: Double)
--   True
--   
--   &gt;&gt;&gt; nextUp (-0) == (0x1p-1074 :: Double)
--   True
--   
--   &gt;&gt;&gt; nextUp (-0x1p-1074) :: Double -- should be negative zero
--   -0.0
--   </pre>
nextUp :: RealFloat a => a -> a

-- | IEEE 754 <tt>nextDown</tt> operation.
--   
--   <pre>
--   &gt;&gt;&gt; nextDown 1 == (0x1.ffff_ffff_ffff_fp-1 :: Double)
--   True
--   
--   &gt;&gt;&gt; nextDown 1 == (0x1.fffffep-1 :: Float)
--   True
--   
--   &gt;&gt;&gt; nextDown (1/0) == (maxFinite :: Double)
--   True
--   
--   &gt;&gt;&gt; nextDown (-1/0) == (-1/0 :: Double)
--   True
--   
--   &gt;&gt;&gt; nextDown 0 == (-0x1p-1074 :: Double)
--   True
--   
--   &gt;&gt;&gt; nextDown (-0) == (-0x1p-1074 :: Double)
--   True
--   
--   &gt;&gt;&gt; nextDown 0x1p-1074 -- should be positive zero
--   0.0
--   
--   &gt;&gt;&gt; nextDown 0x1p-1022 == (0x0.ffff_ffff_ffff_fp-1022 ::Double)
--   True
--   </pre>
nextDown :: RealFloat a => a -> a

-- | <pre>
--   &gt;&gt;&gt; nextTowardZero 1 == (0x1.ffff_ffff_ffff_fp-1 :: Double)
--   True
--   
--   &gt;&gt;&gt; nextTowardZero 1 == (0x1.fffffep-1 :: Float)
--   True
--   
--   &gt;&gt;&gt; nextTowardZero (1/0) == (maxFinite :: Double)
--   True
--   
--   &gt;&gt;&gt; nextTowardZero (-1/0) == (-maxFinite :: Double)
--   True
--   
--   &gt;&gt;&gt; nextTowardZero 0 :: Double -- should be positive zero
--   0.0
--   
--   &gt;&gt;&gt; nextTowardZero (-0 :: Double) -- should be negative zero
--   -0.0
--   
--   &gt;&gt;&gt; nextTowardZero 0x1p-1074 :: Double
--   0.0
--   </pre>
nextTowardZero :: RealFloat a => a -> a
nextUp_positive :: RealFloat a => a -> a
nextDown_positive :: RealFloat a => a -> a

-- | <pre>
--   nextUpFloat 1 == 0x1.000002p0
--   </pre>
--   
--   <pre>
--   nextUpFloat (1/0) == 1/0
--   </pre>
--   
--   <pre>
--   nextUpFloat (-1/0) == - maxFinite
--   </pre>
--   
--   <pre>
--   nextUpFloat 0 == 0x1p-149
--   </pre>
--   
--   <pre>
--   nextUpFloat (-0) == 0x1p-149
--   </pre>
--   
--   <pre>
--   isNegativeZero (nextUpFloat (-0x1p-149))
--   </pre>
nextUpFloat :: Float -> Float

-- | <pre>
--   nextUpDouble 1 == 0x1.0000_0000_0000_1p0
--   </pre>
--   
--   <pre>
--   nextUpDouble (1/0) == 1/0
--   </pre>
--   
--   <pre>
--   nextUpDouble (-1/0) == - maxFinite
--   </pre>
--   
--   <pre>
--   nextUpDouble 0 == 0x1p-1074
--   </pre>
--   
--   <pre>
--   nextUpDouble (-0) == 0x1p-1074
--   </pre>
--   
--   <pre>
--   isNegativeZero (nextUpDouble (-0x1p-1074))
--   </pre>
nextUpDouble :: Double -> Double

-- | <pre>
--   nextDownFloat 1 == 0x1.fffffep-1
--   </pre>
--   
--   <pre>
--   nextDownFloat (1/0) == maxFinite
--   </pre>
--   
--   <pre>
--   nextDownFloat (-1/0) == -1/0
--   </pre>
--   
--   <pre>
--   nextDownFloat 0 == -0x1p-149
--   </pre>
--   
--   <pre>
--   nextDownFloat (-0) == -0x1p-149
--   </pre>
--   
--   <pre>
--   nextDownFloat 0x1p-149 == 0
--   </pre>
nextDownFloat :: Float -> Float

-- | <pre>
--   nextDownDouble 1 == 0x1.ffff_ffff_ffff_fp-1
--   </pre>
--   
--   <pre>
--   nextDownDouble (1/0) == maxFinite
--   </pre>
--   
--   <pre>
--   nextDownDouble (-1/0) == -1/0
--   </pre>
--   
--   <pre>
--   nextDownDouble 0 == -0x1p-1074
--   </pre>
--   
--   <pre>
--   nextDownDouble (-0) == -0x1p-1074
--   </pre>
--   
--   <pre>
--   nextDownDouble 0x1p-1074 == 0
--   </pre>
nextDownDouble :: Double -> Double

-- | <pre>
--   nextTowardZeroFloat 1 == 0x1.fffffep-1
--   </pre>
--   
--   <pre>
--   nextTowardZeroFloat (-1) == -0x1.fffffep-1
--   </pre>
--   
--   <pre>
--   nextTowardZeroFloat (1/0) == maxFinite
--   </pre>
--   
--   <pre>
--   nextTowardZeroFloat (-1/0) == -maxFinite
--   </pre>
--   
--   <pre>
--   nextTowardZeroFloat 0 == 0
--   </pre>
--   
--   <pre>
--   isNegativeZero (nextTowardZeroFloat (-0))
--   </pre>
--   
--   <pre>
--   nextTowardZeroFloat 0x1p-149 == 0
--   </pre>
nextTowardZeroFloat :: Float -> Float

-- | <pre>
--   nextTowardZeroDouble 1 == 0x1.ffff_ffff_ffff_fp-1
--   </pre>
--   
--   <pre>
--   nextTowardZeroDouble (-1) == -0x1.ffff_ffff_ffff_fp-1
--   </pre>
--   
--   <pre>
--   nextTowardZeroDouble (1/0) == maxFinite
--   </pre>
--   
--   <pre>
--   nextTowardZeroDouble (-1/0) == -maxFinite
--   </pre>
--   
--   <pre>
--   nextTowardZeroDouble 0 == 0
--   </pre>
--   
--   <pre>
--   isNegativeZero (nextTowardZeroDouble (-0))
--   </pre>
--   
--   <pre>
--   nextTowardZeroDouble 0x1p-1074 == 0
--   </pre>
nextTowardZeroDouble :: Double -> Double
fusedMultiplyAddDouble :: Double -> Double -> Double -> Double
fusedMultiplyAddFloat :: Float -> Float -> Float -> Float
isMantissaEven :: RealFloat a => a -> Bool

-- | Returns <tt>x := a + b</tt> and <tt>x - &lt;the exact value of (a +
--   b)&gt;</tt>.
--   
--   This function does not avoid undue overflow; For example, the second
--   component of <tt>twoSum (0x1.017bd555b0b1fp1022)
--   (-0x1.fffffffffffffp1023)</tt> is a NaN.
--   
--   <pre>
--   \(a :: Double) (b :: Double) -&gt; let (_,expMax) = floatRange a in max (exponent a) (exponent b) &lt; expMax ==&gt; let (x, y) = twoSum a b in a + b == x &amp;&amp; toRational a + toRational b == toRational x + toRational y
--   </pre>
twoSum :: RealFloat a => a -> a -> (a, a)

-- | Addition, with round to nearest odd floating-point number. Like
--   <a>twoSum</a>, this function does not handle undue overflow.
addToOdd :: RealFloat a => a -> a -> a
split :: RealFloat a => a -> (a, a)

-- | <pre>
--   \(a :: Double) (b :: Double) -&gt; let (x, y) = twoProduct a b in a * b == x &amp;&amp; fromRational (toRational a * toRational b - toRational x) == y
--   </pre>
twoProduct :: RealFloat a => a -> a -> (a, a)
twoProductFloat_viaDouble :: Float -> Float -> (Float, Float)
twoProduct_nonscaling :: RealFloat a => a -> a -> (a, a)
twoProductFloat :: Float -> Float -> (Float, Float)
twoProductDouble :: Double -> Double -> (Double, Double)

-- | IEEE 754 <tt>fusedMultiplyAdd</tt> operation.
--   
--   May make use of hardware FMA instructions if the target architecture
--   has it; set <tt>fma3</tt> package flag on x86 systems.
--   
--   <pre>
--   \(a :: Double) (b :: Double) (c :: Double) -&gt; fusedMultiplyAdd a b c == fromRational (toRational a * toRational b + toRational c)
--   </pre>
fusedMultiplyAdd :: RealFloat a => a -> a -> a -> a
fusedMultiplyAddFloat_viaDouble :: Float -> Float -> Float -> Float

-- | IEEE 754 <tt>addition</tt> operation.
genericAdd :: (RealFloat a, RealFloat b) => a -> a -> b
infixl 6 `genericAdd`

-- | IEEE 754 <tt>subtraction</tt> operation.
genericSub :: (RealFloat a, RealFloat b) => a -> a -> b
infixl 6 `genericSub`

-- | IEEE 754 <tt>multiplication</tt> operation.
genericMul :: (RealFloat a, RealFloat b) => a -> a -> b
infixl 7 `genericMul`

-- | IEEE 754 <tt>division</tt> operation.
genericDiv :: (RealFloat a, RealFloat b) => a -> a -> b
infixl 7 `genericDiv`

-- | IEEE 754 <tt>fusedMultiplyAdd</tt> operation.
genericFusedMultiplyAdd :: (RealFloat a, RealFloat b) => a -> a -> a -> b

-- | Returns True if <tt>a</tt> is a subtype of <tt>b</tt>
--   
--   <pre>
--   &gt;&gt;&gt; isSubFloatingType (undefined :: Float) (undefined :: Double)
--   True
--   
--   &gt;&gt;&gt; isSubFloatingType (undefined :: Double) (undefined :: Float)
--   False
--   
--   &gt;&gt;&gt; isSubFloatingType (undefined :: Double) (undefined :: Double)
--   True
--   </pre>
isSubFloatingType :: (RealFloat a, RealFloat b) => a -> b -> Bool

-- | Returns True if <tt>a</tt> is a subtype of <tt>b</tt>
--   
--   <pre>
--   &gt;&gt;&gt; isSubFloatingTypeProxy (Proxy :: Proxy Float) (Proxy :: Proxy Double)
--   True
--   
--   &gt;&gt;&gt; isSubFloatingTypeProxy (Proxy :: Proxy Double) (Proxy :: Proxy Float)
--   False
--   
--   &gt;&gt;&gt; isSubFloatingTypeProxy (Proxy :: Proxy Double) (Proxy :: Proxy Double)
--   True
--   </pre>
isSubFloatingTypeProxy :: (RealFloat a, RealFloat b) => Proxy a -> Proxy b -> Bool

-- | IEEE 754 <tt>augmentedAddition</tt> operation.
augmentedAddition :: RealFloat a => a -> a -> (a, a)

-- | IEEE 754 <tt>augmentedSubtraction</tt> operation.
augmentedSubtraction :: RealFloat a => a -> a -> (a, a)

-- | IEEE 754 <tt>augmentedMultiplication</tt> operation.
augmentedMultiplication :: RealFloat a => a -> a -> (a, a)

-- | IEEE 754 <tt>remainder</tt> operation.
--   
--   &lt;math&gt;, where n is the integer nearest the exact number
--   &lt;math&gt;
remainder :: RealFloat a => a -> a -> a

-- | IEEE 754 <tt>roundToIntegralTiesToEven</tt> operation.
--   
--   <pre>
--   \(x :: Double) -&gt; isFinite x ==&gt; (round' x == fromInteger (round x))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; round' (-0.5)
--   -0.0
--   </pre>
round' :: RealFloat a => a -> a

-- | IEEE 754 <tt>roundToIntegralTiesToAway</tt> operation.
--   
--   <pre>
--   \(x :: Double) -&gt; isFinite x ==&gt; roundAway' x == fromInteger (roundAway x)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; roundAway' (-0.5)
--   -1.0
--   
--   &gt;&gt;&gt; roundAway' (-0.4)
--   -0.0
--   </pre>
roundAway' :: RealFloat a => a -> a

-- | IEEE 754 <tt>roundToIntegralTowardZero</tt> operation.
--   
--   <pre>
--   \(x :: Double) -&gt; isFinite x ==&gt; truncate' x == fromInteger (truncate x)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; truncate' (-0.5)
--   -0.0
--   </pre>
truncate' :: RealFloat a => a -> a

-- | IEEE 754 <tt>roundToIntegralTowardPositive</tt> operation.
--   
--   <pre>
--   \(x :: Double) -&gt; isFinite x ==&gt; ceiling' x == fromInteger (ceiling x)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ceiling' (-0.8)
--   -0.0
--   
--   &gt;&gt;&gt; ceiling' (-0.5)
--   -0.0
--   </pre>
ceiling' :: RealFloat a => a -> a

-- | IEEE 754 <tt>roundToIntegralTowardNegative</tt> operation.
--   
--   <pre>
--   \(x :: Double) -&gt; isFinite x ==&gt; floor' x == fromInteger (floor x)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; floor' (-0.1)
--   -1.0
--   
--   &gt;&gt;&gt; floor' (-0)
--   -0.0
--   </pre>
floor' :: RealFloat a => a -> a

-- | IEEE 754 <tt>convertToIntegerTiesToAway</tt> operation.
--   
--   <pre>
--   &gt;&gt;&gt; roundAway 4.5
--   5
--   </pre>
roundAway :: (RealFrac a, Integral b) => a -> b
newtype RoundTowardZero a
RoundTowardZero :: a -> RoundTowardZero a
[roundTowardZero] :: RoundTowardZero a -> a
newtype RoundTowardNegative a
RoundTowardNegative :: a -> RoundTowardNegative a
[roundTowardNegative] :: RoundTowardNegative a -> a
newtype RoundTowardPositive a
RoundTowardPositive :: a -> RoundTowardPositive a
[roundTowardPositive] :: RoundTowardPositive a -> a
newtype RoundTiesToAway a
RoundTiesToAway :: a -> RoundTiesToAway a
[roundTiesToAway] :: RoundTiesToAway a -> a
newtype RoundTiesToEven a
RoundTiesToEven :: a -> RoundTiesToEven a
[roundTiesToEven] :: RoundTiesToEven a -> a
class Functor f => RoundingStrategy f
exact :: RoundingStrategy f => a -> f a
inexact :: RoundingStrategy f => Ordering -> Bool -> Int -> a -> a -> f a
doRound :: RoundingStrategy f => Bool -> Ordering -> Bool -> Int -> a -> a -> f a
quotRemByExpt :: Integer -> Integer -> Int -> (Integer, Integer)
multiplyByExpt :: Integer -> Integer -> Int -> Integer
isDivisibleByExpt :: Integer -> Integer -> Int -> Integer -> Bool

-- | Assumption: <tt>n &gt;= 0</tt>, <tt>e &gt;= 0</tt>, and <tt>r == n
--   `<a>rem</a>` base^(e+1)</tt>
--   
--   Returns <tt>compare r (base^e)</tt>.
compareWithExpt :: Integer -> Integer -> Integer -> Int -> Ordering
encodeFloatTiesToEven :: RealFloat a => Integer -> Int -> a
encodeFloatTiesToAway :: RealFloat a => Integer -> Int -> a
encodeFloatTowardPositive :: RealFloat a => Integer -> Int -> a
encodeFloatTowardNegative :: RealFloat a => Integer -> Int -> a
encodeFloatTowardZero :: RealFloat a => Integer -> Int -> a
encodeFloatR :: (RealFloat a, RoundingStrategy f) => Integer -> Int -> f a
encodePositiveFloatR :: (RealFloat a, RoundingStrategy f) => Bool -> Integer -> Int -> f a
encodePositiveFloatR# :: forall f a. (RealFloat a, RoundingStrategy f) => Bool -> Integer -> Int# -> f a

-- | IEEE 754 <tt>scaleB</tt> operation, with each rounding attributes.
scaleFloatTiesToEven :: RealFloat a => Int -> a -> a

-- | IEEE 754 <tt>scaleB</tt> operation, with each rounding attributes.
scaleFloatTiesToAway :: RealFloat a => Int -> a -> a

-- | IEEE 754 <tt>scaleB</tt> operation, with each rounding attributes.
scaleFloatTowardPositive :: RealFloat a => Int -> a -> a

-- | IEEE 754 <tt>scaleB</tt> operation, with each rounding attributes.
scaleFloatTowardNegative :: RealFloat a => Int -> a -> a

-- | IEEE 754 <tt>scaleB</tt> operation, with each rounding attributes.
scaleFloatTowardZero :: RealFloat a => Int -> a -> a
scaleFloatR :: (RealFloat a, RoundingStrategy f) => Int -> a -> f a
scaleFloatR# :: (RealFloat a, RoundingStrategy f) => Int# -> a -> f a

-- | IEEE 754 <tt>convertFromInt</tt> operation, with each rounding
--   attributes.
fromIntegerTiesToEven :: RealFloat a => Integer -> a

-- | IEEE 754 <tt>convertFromInt</tt> operation, with each rounding
--   attributes.
fromIntegerTiesToAway :: RealFloat a => Integer -> a

-- | IEEE 754 <tt>convertFromInt</tt> operation, with each rounding
--   attributes.
fromIntegerTowardPositive :: RealFloat a => Integer -> a

-- | IEEE 754 <tt>convertFromInt</tt> operation, with each rounding
--   attributes.
fromIntegerTowardNegative :: RealFloat a => Integer -> a

-- | IEEE 754 <tt>convertFromInt</tt> operation, with each rounding
--   attributes.
fromIntegerTowardZero :: RealFloat a => Integer -> a

-- | IEEE 754 <tt>convertFromInt</tt> operation, with each rounding
--   attributes.
fromIntegralTiesToEven :: (Integral i, RealFloat a) => i -> a

-- | IEEE 754 <tt>convertFromInt</tt> operation, with each rounding
--   attributes.
fromIntegralTiesToAway :: (Integral i, RealFloat a) => i -> a

-- | IEEE 754 <tt>convertFromInt</tt> operation, with each rounding
--   attributes.
fromIntegralTowardPositive :: (Integral i, RealFloat a) => i -> a

-- | IEEE 754 <tt>convertFromInt</tt> operation, with each rounding
--   attributes.
fromIntegralTowardNegative :: (Integral i, RealFloat a) => i -> a

-- | IEEE 754 <tt>convertFromInt</tt> operation, with each rounding
--   attributes.
fromIntegralTowardZero :: (Integral i, RealFloat a) => i -> a
fromIntegerR :: (RealFloat a, RoundingStrategy f) => Integer -> f a
fromIntegralR :: (Integral i, RealFloat a, RoundingStrategy f) => i -> f a
fromIntegralRBits :: forall i f a. (Integral i, Bits i, RealFloat a, RoundingStrategy f) => i -> f a

-- | <pre>
--   &gt;&gt;&gt; boundsForExactConversion (Proxy :: Proxy Double) :: (Maybe Integer, Maybe Integer) -- (Just (-2^53),Just (2^53))
--   (Just (-9007199254740992),Just 9007199254740992)
--   
--   &gt;&gt;&gt; boundsForExactConversion (Proxy :: Proxy Double) :: (Maybe Int32, Maybe Int32) -- the conversion is always exact
--   (Nothing,Nothing)
--   
--   &gt;&gt;&gt; boundsForExactConversion (Proxy :: Proxy Float) :: (Maybe Word, Maybe Word) -- (Nothing,Just (2^24))
--   (Nothing,Just 16777216)
--   </pre>
boundsForExactConversion :: forall a i. (Integral i, Bits i, RealFloat a) => Proxy a -> (Maybe i, Maybe i)
minBoundAsInteger :: Bits i => i -> Maybe Integer
maxBoundAsInteger :: Bits i => i -> Maybe Integer
positiveWordToBinaryFloatR :: (RealFloat a, RoundingStrategy f) => Bool -> Word -> f a
positiveWordToBinaryFloatR# :: forall f a. (RealFloat a, RoundingStrategy f) => Bool -> Word# -> f a
fromPositiveIntegerR :: forall f a. (RealFloat a, RoundingStrategy f) => Bool -> Integer -> f a
fromRationalTiesToEven :: RealFloat a => Rational -> a
fromRationalTiesToAway :: RealFloat a => Rational -> a
fromRationalTowardPositive :: RealFloat a => Rational -> a
fromRationalTowardNegative :: RealFloat a => Rational -> a
fromRationalTowardZero :: RealFloat a => Rational -> a
fromRationalR :: (RealFloat a, RoundingStrategy f) => Rational -> f a
fromRatioR :: (RealFloat a, RoundingStrategy f) => Integer -> Integer -> f a
fromPositiveRatioR :: forall f a. (RealFloat a, RoundingStrategy f) => Bool -> Integer -> Integer -> f a
castHalfToWord16 :: Half -> Word16
castWord16ToHalf :: Word16 -> Half
nextUpHalf :: Half -> Half
nextDownHalf :: Half -> Half
nextTowardZeroHalf :: Half -> Half
isNormalHalf :: Half -> Bool
isFiniteHalf :: Half -> Bool
isSignMinusHalf :: Half -> Bool
classifyHalf :: Half -> Class
halfToFloat :: Half -> Float
halfToDouble :: Half -> Double
floatToHalf :: Float -> Half
doubleToHalf :: Double -> Half


-- | This module provides IEEE 754-compliant operations for floating-point
--   numbers.
--   
--   The functions in this module assume that the given floating-point type
--   conform to IEEE 754 format.
--   
--   Since <a>RealFloat</a> constraint is insufficient to query properties
--   of a NaN, the functions here assumes all NaN as positive, quiet. If
--   you want better treatment for NaNs, use the module
--   <a>Numeric.Floating.IEEE.NaN</a>.
--   
--   Since floating-point exceptions cannot be accessed from Haskell in
--   normal way, the operations provided by this module ignore exceptional
--   behavior. Don't let fp exceptions trap.
--   
--   On i386 target, you may need to set <tt>-msse2</tt> option to get
--   correct floating-point behavior.
module Numeric.Floating.IEEE

-- | IEEE 754 <tt>roundToIntegralTiesToEven</tt> operation.
--   
--   <pre>
--   \(x :: Double) -&gt; isFinite x ==&gt; (round' x == fromInteger (round x))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; round' (-0.5)
--   -0.0
--   </pre>
round' :: RealFloat a => a -> a

-- | IEEE 754 <tt>roundToIntegralTiesToAway</tt> operation.
--   
--   <pre>
--   \(x :: Double) -&gt; isFinite x ==&gt; roundAway' x == fromInteger (roundAway x)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; roundAway' (-0.5)
--   -1.0
--   
--   &gt;&gt;&gt; roundAway' (-0.4)
--   -0.0
--   </pre>
roundAway' :: RealFloat a => a -> a

-- | IEEE 754 <tt>roundToIntegralTowardZero</tt> operation.
--   
--   <pre>
--   \(x :: Double) -&gt; isFinite x ==&gt; truncate' x == fromInteger (truncate x)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; truncate' (-0.5)
--   -0.0
--   </pre>
truncate' :: RealFloat a => a -> a

-- | IEEE 754 <tt>roundToIntegralTowardPositive</tt> operation.
--   
--   <pre>
--   \(x :: Double) -&gt; isFinite x ==&gt; ceiling' x == fromInteger (ceiling x)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ceiling' (-0.8)
--   -0.0
--   
--   &gt;&gt;&gt; ceiling' (-0.5)
--   -0.0
--   </pre>
ceiling' :: RealFloat a => a -> a

-- | IEEE 754 <tt>roundToIntegralTowardNegative</tt> operation.
--   
--   <pre>
--   \(x :: Double) -&gt; isFinite x ==&gt; floor' x == fromInteger (floor x)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; floor' (-0.1)
--   -1.0
--   
--   &gt;&gt;&gt; floor' (-0)
--   -0.0
--   </pre>
floor' :: RealFloat a => a -> a

-- | IEEE 754 <tt>nextUp</tt> operation.
--   
--   <pre>
--   &gt;&gt;&gt; nextUp 1 == (0x1.000002p0 :: Float)
--   True
--   
--   &gt;&gt;&gt; nextUp 1 == (0x1.0000_0000_0000_1p0 :: Double)
--   True
--   
--   &gt;&gt;&gt; nextUp (1/0) == (1/0 :: Double)
--   True
--   
--   &gt;&gt;&gt; nextUp (-1/0) == (- maxFinite :: Double)
--   True
--   
--   &gt;&gt;&gt; nextUp 0 == (0x1p-1074 :: Double)
--   True
--   
--   &gt;&gt;&gt; nextUp (-0) == (0x1p-1074 :: Double)
--   True
--   
--   &gt;&gt;&gt; nextUp (-0x1p-1074) :: Double -- should be negative zero
--   -0.0
--   </pre>
nextUp :: RealFloat a => a -> a

-- | IEEE 754 <tt>nextDown</tt> operation.
--   
--   <pre>
--   &gt;&gt;&gt; nextDown 1 == (0x1.ffff_ffff_ffff_fp-1 :: Double)
--   True
--   
--   &gt;&gt;&gt; nextDown 1 == (0x1.fffffep-1 :: Float)
--   True
--   
--   &gt;&gt;&gt; nextDown (1/0) == (maxFinite :: Double)
--   True
--   
--   &gt;&gt;&gt; nextDown (-1/0) == (-1/0 :: Double)
--   True
--   
--   &gt;&gt;&gt; nextDown 0 == (-0x1p-1074 :: Double)
--   True
--   
--   &gt;&gt;&gt; nextDown (-0) == (-0x1p-1074 :: Double)
--   True
--   
--   &gt;&gt;&gt; nextDown 0x1p-1074 -- should be positive zero
--   0.0
--   
--   &gt;&gt;&gt; nextDown 0x1p-1022 == (0x0.ffff_ffff_ffff_fp-1022 ::Double)
--   True
--   </pre>
nextDown :: RealFloat a => a -> a

-- | <pre>
--   &gt;&gt;&gt; nextTowardZero 1 == (0x1.ffff_ffff_ffff_fp-1 :: Double)
--   True
--   
--   &gt;&gt;&gt; nextTowardZero 1 == (0x1.fffffep-1 :: Float)
--   True
--   
--   &gt;&gt;&gt; nextTowardZero (1/0) == (maxFinite :: Double)
--   True
--   
--   &gt;&gt;&gt; nextTowardZero (-1/0) == (-maxFinite :: Double)
--   True
--   
--   &gt;&gt;&gt; nextTowardZero 0 :: Double -- should be positive zero
--   0.0
--   
--   &gt;&gt;&gt; nextTowardZero (-0 :: Double) -- should be negative zero
--   -0.0
--   
--   &gt;&gt;&gt; nextTowardZero 0x1p-1074 :: Double
--   0.0
--   </pre>
nextTowardZero :: RealFloat a => a -> a

-- | IEEE 754 <tt>remainder</tt> operation.
--   
--   &lt;math&gt;, where n is the integer nearest the exact number
--   &lt;math&gt;
remainder :: RealFloat a => a -> a -> a

-- | IEEE 754 <tt>scaleB</tt> operation, with each rounding attributes.
scaleFloatTiesToEven :: RealFloat a => Int -> a -> a

-- | IEEE 754 <tt>scaleB</tt> operation, with each rounding attributes.
scaleFloatTiesToAway :: RealFloat a => Int -> a -> a

-- | IEEE 754 <tt>scaleB</tt> operation, with each rounding attributes.
scaleFloatTowardPositive :: RealFloat a => Int -> a -> a

-- | IEEE 754 <tt>scaleB</tt> operation, with each rounding attributes.
scaleFloatTowardNegative :: RealFloat a => Int -> a -> a

-- | IEEE 754 <tt>scaleB</tt> operation, with each rounding attributes.
scaleFloatTowardZero :: RealFloat a => Int -> a -> a

-- | <a>exponent</a> corresponds to the second component of
--   <a>decodeFloat</a>. <tt><a>exponent</a> 0 = 0</tt> and for finite
--   nonzero <tt>x</tt>, <tt><a>exponent</a> x = snd (<a>decodeFloat</a> x)
--   + <a>floatDigits</a> x</tt>. If <tt>x</tt> is a finite floating-point
--   number, it is equal in value to <tt><a>significand</a> x * b ^^
--   <a>exponent</a> x</tt>, where <tt>b</tt> is the floating-point radix.
--   The behaviour is unspecified on infinite or <tt>NaN</tt> values.
exponent :: RealFloat a => a -> Int
(+) :: Num a => a -> a -> a
infixl 6 +
(-) :: Num a => a -> a -> a
infixl 6 -
(*) :: Num a => a -> a -> a
infixl 7 *

-- | Fractional division.
(/) :: Fractional a => a -> a -> a
infixl 7 /
sqrt :: Floating a => a -> a

-- | IEEE 754 <tt>fusedMultiplyAdd</tt> operation.
--   
--   May make use of hardware FMA instructions if the target architecture
--   has it; set <tt>fma3</tt> package flag on x86 systems.
--   
--   <pre>
--   \(a :: Double) (b :: Double) (c :: Double) -&gt; fusedMultiplyAdd a b c == fromRational (toRational a * toRational b + toRational c)
--   </pre>
fusedMultiplyAdd :: RealFloat a => a -> a -> a -> a

-- | IEEE 754 <tt>addition</tt> operation.
genericAdd :: (RealFloat a, RealFloat b) => a -> a -> b
infixl 6 `genericAdd`

-- | IEEE 754 <tt>subtraction</tt> operation.
genericSub :: (RealFloat a, RealFloat b) => a -> a -> b
infixl 6 `genericSub`

-- | IEEE 754 <tt>multiplication</tt> operation.
genericMul :: (RealFloat a, RealFloat b) => a -> a -> b
infixl 7 `genericMul`

-- | IEEE 754 <tt>division</tt> operation.
genericDiv :: (RealFloat a, RealFloat b) => a -> a -> b
infixl 7 `genericDiv`

-- | IEEE 754 <tt>fusedMultiplyAdd</tt> operation.
genericFusedMultiplyAdd :: (RealFloat a, RealFloat b) => a -> a -> a -> b

-- | IEEE 754 <tt>convertFromInt</tt> operation, with each rounding
--   attributes.
fromIntegerTiesToEven :: RealFloat a => Integer -> a

-- | IEEE 754 <tt>convertFromInt</tt> operation, with each rounding
--   attributes.
fromIntegerTiesToAway :: RealFloat a => Integer -> a

-- | IEEE 754 <tt>convertFromInt</tt> operation, with each rounding
--   attributes.
fromIntegerTowardPositive :: RealFloat a => Integer -> a

-- | IEEE 754 <tt>convertFromInt</tt> operation, with each rounding
--   attributes.
fromIntegerTowardNegative :: RealFloat a => Integer -> a

-- | IEEE 754 <tt>convertFromInt</tt> operation, with each rounding
--   attributes.
fromIntegerTowardZero :: RealFloat a => Integer -> a

-- | IEEE 754 <tt>convertFromInt</tt> operation, with each rounding
--   attributes.
fromIntegralTiesToEven :: (Integral i, RealFloat a) => i -> a

-- | IEEE 754 <tt>convertFromInt</tt> operation, with each rounding
--   attributes.
fromIntegralTiesToAway :: (Integral i, RealFloat a) => i -> a

-- | IEEE 754 <tt>convertFromInt</tt> operation, with each rounding
--   attributes.
fromIntegralTowardPositive :: (Integral i, RealFloat a) => i -> a

-- | IEEE 754 <tt>convertFromInt</tt> operation, with each rounding
--   attributes.
fromIntegralTowardNegative :: (Integral i, RealFloat a) => i -> a

-- | IEEE 754 <tt>convertFromInt</tt> operation, with each rounding
--   attributes.
fromIntegralTowardZero :: (Integral i, RealFloat a) => i -> a
fromRationalTiesToEven :: RealFloat a => Rational -> a
fromRationalTiesToAway :: RealFloat a => Rational -> a
fromRationalTowardPositive :: RealFloat a => Rational -> a
fromRationalTowardNegative :: RealFloat a => Rational -> a
fromRationalTowardZero :: RealFloat a => Rational -> a

-- | <tt><a>round</a> x</tt> returns the nearest integer to <tt>x</tt>; the
--   even integer if <tt>x</tt> is equidistant between two integers
round :: (RealFrac a, Integral b) => a -> b

-- | IEEE 754 <tt>convertToIntegerTiesToAway</tt> operation.
--   
--   <pre>
--   &gt;&gt;&gt; roundAway 4.5
--   5
--   </pre>
roundAway :: (RealFrac a, Integral b) => a -> b

-- | <tt><a>truncate</a> x</tt> returns the integer nearest <tt>x</tt>
--   between zero and <tt>x</tt>
truncate :: (RealFrac a, Integral b) => a -> b

-- | <tt><a>ceiling</a> x</tt> returns the least integer not less than
--   <tt>x</tt>
ceiling :: (RealFrac a, Integral b) => a -> b

-- | <tt><a>floor</a> x</tt> returns the greatest integer not greater than
--   <tt>x</tt>
floor :: (RealFrac a, Integral b) => a -> b

-- | Similar to <a>realToFrac</a>, but treats NaN, infinities, negative
--   zero even if the rewrite rule is off.
realFloatToFrac :: (RealFloat a, Fractional b) => a -> b
canonicalize :: RealFloat a => a -> a

-- | Unary negation.
negate :: Num a => a -> a

-- | Absolute value.
abs :: Num a => a -> a
data Class
SignalingNaN :: Class
QuietNaN :: Class
NegativeInfinity :: Class
NegativeNormal :: Class
NegativeSubnormal :: Class
NegativeZero :: Class
PositiveZero :: Class
PositiveSubnormal :: Class
PositiveNormal :: Class
PositiveInfinity :: Class

-- | Treats NaNs as quiet
classify :: RealFloat a => a -> Class

-- | IEEE 754 <tt>isSignMinus</tt> operation.
--   
--   Since <a>RealFloat</a> constraint is insufficient to query the sign of
--   NaNs, this function treats all NaNs as positive.
isSignMinus :: RealFloat a => a -> Bool

-- | IEEE 754 <tt>isNormal</tt> operation.
isNormal :: RealFloat a => a -> Bool

-- | IEEE 754 <tt>isFinite</tt> operation.
isFinite :: RealFloat a => a -> Bool

-- | IEEE 754 <tt>isZero</tt> operation.
isZero :: RealFloat a => a -> Bool

-- | <a>True</a> if the argument is too small to be represented in
--   normalized format
isDenormalized :: RealFloat a => a -> Bool

-- | <a>True</a> if the argument is an IEEE infinity or negative infinity
isInfinite :: RealFloat a => a -> Bool

-- | <a>True</a> if the argument is an IEEE "not-a-number" (NaN) value
isNaN :: RealFloat a => a -> Bool

-- | a constant function, returning the radix of the representation (often
--   <tt>2</tt>)
floatRadix :: RealFloat a => a -> Integer

-- | Comparison with IEEE 754 <tt>totalOrder</tt> predicate.
--   
--   Since <a>RealFloat</a> constraint is insufficient to query the sign
--   and payload of NaNs, this function treats all NaNs as positive.
--   
--   Floating-point numbers are ordered as, &lt;math&gt;.
compareByTotalOrder :: RealFloat a => a -> a -> Ordering

-- | Comparison with IEEE 754 <tt>totalOrderMag</tt> predicate.
compareByTotalOrderMag :: RealFloat a => a -> a -> Ordering

-- | IEEE 754 <tt>augmentedAddition</tt> operation.
augmentedAddition :: RealFloat a => a -> a -> (a, a)

-- | IEEE 754 <tt>augmentedSubtraction</tt> operation.
augmentedSubtraction :: RealFloat a => a -> a -> (a, a)

-- | IEEE 754 <tt>augmentedMultiplication</tt> operation.
augmentedMultiplication :: RealFloat a => a -> a -> (a, a)

-- | IEEE 754 <tt>minimum</tt> operation. <tt>-0</tt> is smaller than
--   <tt>+0</tt>. Propagates NaNs.
minimum' :: RealFloat a => a -> a -> a

-- | IEEE 754 <tt>minimumNumber</tt> operation. <tt>-0</tt> is smaller than
--   <tt>+0</tt>. Treats NaNs as missing data.
minimumNumber :: RealFloat a => a -> a -> a

-- | IEEE 754 <tt>maximum</tt> operation. <tt>-0</tt> is smaller than
--   <tt>+0</tt>. Propagates NaNs.
maximum' :: RealFloat a => a -> a -> a

-- | IEEE 754 <tt>maximumNumber</tt> operation. <tt>-0</tt> is smaller than
--   <tt>+0</tt>. Treats NaNs as missing data.
maximumNumber :: RealFloat a => a -> a -> a

-- | IEEE 754 <tt>minimumMagnitude</tt> operation.
minimumMagnitude :: RealFloat a => a -> a -> a

-- | IEEE 754 <tt>minimumMagnitudeNumber</tt> operation.
minimumMagnitudeNumber :: RealFloat a => a -> a -> a

-- | IEEE 754 <tt>maximumMagnitude</tt> operation.
maximumMagnitude :: RealFloat a => a -> a -> a

-- | IEEE 754 <tt>maximumMagnitudeNumber</tt> operation.
maximumMagnitudeNumber :: RealFloat a => a -> a -> a

-- | <pre>
--   &gt;&gt;&gt; (minPositive :: Float) == 0x1p-149
--   True
--   
--   &gt;&gt;&gt; (minPositive :: Double) == 0x1p-1074
--   True
--   
--   &gt;&gt;&gt; nextDown (minPositive :: Float)
--   0.0
--   
--   &gt;&gt;&gt; nextDown (minPositive :: Double)
--   0.0
--   </pre>
minPositive :: RealFloat a => a

-- | <pre>
--   &gt;&gt;&gt; (minPositiveNormal :: Float) == 0x1p-126
--   True
--   
--   &gt;&gt;&gt; (minPositiveNormal :: Double) == 0x1p-1022
--   True
--   
--   &gt;&gt;&gt; isDenormalized (minPositiveNormal :: Float)
--   False
--   
--   &gt;&gt;&gt; isDenormalized (minPositiveNormal :: Double)
--   False
--   
--   &gt;&gt;&gt; isDenormalized (nextDown (minPositiveNormal :: Float))
--   True
--   
--   &gt;&gt;&gt; isDenormalized (nextDown (minPositiveNormal :: Double))
--   True
--   </pre>
minPositiveNormal :: RealFloat a => a

-- | <pre>
--   &gt;&gt;&gt; (maxFinite :: Float) == 0x1.fffffep+127
--   True
--   
--   &gt;&gt;&gt; (maxFinite :: Double) == 0x1.ffff_ffff_ffff_fp+1023
--   True
--   </pre>
maxFinite :: RealFloat a => a

module Numeric.Floating.IEEE.NaN

-- | An instance of this class supports manipulation of NaN.
class RealFloat a => RealFloatNaN a

-- | Returns the first operand, with the sign of the second.
--   
--   IEEE 754 <tt>copySign</tt> operation.
copySign :: RealFloatNaN a => a -> a -> a

-- | Returns <tt>True</tt> if the operand is a negative number, negative
--   infinity, negative zero, or a NaN with negative sign bit.
--   
--   IEEE 754 <tt>isSignMinus</tt> operation.
isSignMinus :: RealFloatNaN a => a -> Bool

-- | Returns <tt>True</tt> if the operand is a signaling NaN.
--   
--   IEEE 754 <tt>isSignaling</tt> operation.
isSignaling :: RealFloatNaN a => a -> Bool

-- | Returns the payload of a NaN. Returns <tt>-1</tt> if the operand is
--   not a NaN.
--   
--   IEEE 754 <tt>getPayload</tt> operation.
getPayload :: RealFloatNaN a => a -> a

-- | Returns a quiet NaN with a given payload. Returns a positive zero if
--   the payload is invalid.
--   
--   IEEE 754 <tt>setPayload</tt> operation.
setPayload :: RealFloatNaN a => a -> a

-- | Returns a signaling NaN with a given payload. Returns a positive zero
--   if the payload is invalid.
--   
--   IEEE 754 <tt>setPayloadSignaling</tt> operation.
setPayloadSignaling :: RealFloatNaN a => a -> a

-- | IEEE 754 <tt>class</tt> operation.
classify :: RealFloatNaN a => a -> Class

-- | Equality with IEEE 754 <tt>totalOrder</tt> operation.
equalByTotalOrder :: RealFloatNaN a => a -> a -> Bool

-- | Comparison with IEEE 754 <tt>totalOrder</tt> operation.
compareByTotalOrder :: RealFloatNaN a => a -> a -> Ordering
data Class
SignalingNaN :: Class
QuietNaN :: Class
NegativeInfinity :: Class
NegativeNormal :: Class
NegativeSubnormal :: Class
NegativeZero :: Class
PositiveZero :: Class
PositiveSubnormal :: Class
PositiveNormal :: Class
PositiveInfinity :: Class
newtype TotallyOrdered a
TotallyOrdered :: a -> TotallyOrdered a

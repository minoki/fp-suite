-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/minoki/haskell-floating-point/tree/%E4%B8%BB/fp-ieee#readme</a>
@package fp-ieee
@version 0.1.0.0

module Numeric.Floating.IEEE.Internal

-- | IEEE 754 <tt>convertFromInt</tt> operation, with each rounding
--   attributes.
fromIntegerTiesToEven :: RealFloat a => Integer -> a

-- | IEEE 754 <tt>convertFromInt</tt> operation, with each rounding
--   attributes.
fromIntegerTiesToAway :: RealFloat a => Integer -> a

-- | IEEE 754 <tt>convertFromInt</tt> operation, with each rounding
--   attributes.
fromIntegerTowardPositive :: RealFloat a => Integer -> a

-- | IEEE 754 <tt>convertFromInt</tt> operation, with each rounding
--   attributes.
fromIntegerTowardNegative :: RealFloat a => Integer -> a

-- | IEEE 754 <tt>convertFromInt</tt> operation, with each rounding
--   attributes.
fromIntegerTowardZero :: RealFloat a => Integer -> a

-- | IEEE 754 <tt>convertFromInt</tt> operation, with each rounding
--   attributes.
fromIntegralTiesToEven :: (Integral i, RealFloat a) => i -> a

-- | IEEE 754 <tt>convertFromInt</tt> operation, with each rounding
--   attributes.
fromIntegralTiesToAway :: (Integral i, RealFloat a) => i -> a

-- | IEEE 754 <tt>convertFromInt</tt> operation, with each rounding
--   attributes.
fromIntegralTowardPositive :: (Integral i, RealFloat a) => i -> a

-- | IEEE 754 <tt>convertFromInt</tt> operation, with each rounding
--   attributes.
fromIntegralTowardNegative :: (Integral i, RealFloat a) => i -> a

-- | IEEE 754 <tt>convertFromInt</tt> operation, with each rounding
--   attributes.
fromIntegralTowardZero :: (Integral i, RealFloat a) => i -> a
fromRationalTiesToEven :: RealFloat a => Rational -> a
fromRationalTiesToAway :: RealFloat a => Rational -> a
fromRationalTowardPositive :: RealFloat a => Rational -> a
fromRationalTowardNegative :: RealFloat a => Rational -> a
fromRationalTowardZero :: RealFloat a => Rational -> a
encodeFloatTiesToEven :: RealFloat a => Integer -> Int -> a
encodeFloatTiesToAway :: RealFloat a => Integer -> Int -> a
encodeFloatTowardPositive :: RealFloat a => Integer -> Int -> a
encodeFloatTowardNegative :: RealFloat a => Integer -> Int -> a
encodeFloatTowardZero :: RealFloat a => Integer -> Int -> a

-- | <tt><a>truncate</a> x</tt> returns the integer nearest <tt>x</tt>
--   between zero and <tt>x</tt>
truncate :: (RealFrac a, Integral b) => a -> b

-- | <tt><a>round</a> x</tt> returns the nearest integer to <tt>x</tt>; the
--   even integer if <tt>x</tt> is equidistant between two integers
round :: (RealFrac a, Integral b) => a -> b

-- | <tt><a>ceiling</a> x</tt> returns the least integer not less than
--   <tt>x</tt>
ceiling :: (RealFrac a, Integral b) => a -> b

-- | <tt><a>floor</a> x</tt> returns the greatest integer not greater than
--   <tt>x</tt>
floor :: (RealFrac a, Integral b) => a -> b
isFloatBinary32 :: Bool
isDoubleBinary64 :: Bool

-- | <pre>
--   (minPositive :: Float) == 0x1p-149
--   </pre>
--   
--   <pre>
--   (minPositive :: Double) == 0x1p-1074
--   </pre>
--   
--   <pre>
--   nextDown (minPositive :: Float) == 0
--   </pre>
--   
--   <pre>
--   nextDown (minPositive :: Double) == 0
--   </pre>
minPositive :: RealFloat a => a

-- | <pre>
--   (minPositiveNormal :: Float) == 0x1p-126
--   </pre>
--   
--   <pre>
--   (minPositiveNormal :: Double) == 0x1p-1022
--   </pre>
--   
--   <pre>
--   not (isDenormalized (minPositiveNormal :: Float))
--   </pre>
--   
--   <pre>
--   not (isDenormalized (minPositiveNormal :: Double))
--   </pre>
--   
--   <pre>
--   isDenormalized (nextDown (minPositiveNormal :: Float))
--   </pre>
--   
--   <pre>
--   isDenormalized (nextDown (minPositiveNormal :: Double))
--   </pre>
minPositiveNormal :: RealFloat a => a

-- | <pre>
--   (maxFinite :: Float) == 0x1.fffffep+127
--   </pre>
--   
--   <pre>
--   (maxFinite :: Double) == 0x1.ffff_ffff_ffff_fp+1023
--   </pre>
maxFinite :: RealFloat a => a

-- | <pre>
--   negateIntAsWord minBound == fromInteger (negate (fromIntegral (minBound :: Int)))
--   </pre>
negateIntAsWord :: Int -> Word

-- | <pre>
--   absIntAsWord minBound == fromInteger (abs (fromIntegral (minBound :: Int)))
--   </pre>
absIntAsWord :: Int -> Word
data Class
SignalingNaN :: Class
QuietNaN :: Class
NegativeInfinity :: Class
NegativeNormal :: Class
NegativeSubnormal :: Class
NegativeZero :: Class
PositiveZero :: Class
PositiveSubnormal :: Class
PositiveNormal :: Class
PositiveInfinity :: Class

-- | IEEE 754 <tt>isNormal</tt> operation.
isNormal :: RealFloat a => a -> Bool
isFloatNormal :: Float -> Bool
isDoubleNormal :: Double -> Bool

-- | IEEE 754 <tt>isFinite</tt> operation.
isFinite :: RealFloat a => a -> Bool

-- | IEEE 754 <tt>isZero</tt> operation.
isZero :: RealFloat a => a -> Bool

-- | IEEE 754 <tt>isSignMinus</tt> operation.
--   
--   Since <a>RealFloat</a> constraint is insufficient to query the sign of
--   NaNs, this function treats all NaNs as positive.
isSignMinus :: RealFloat a => a -> Bool

-- | Comparison with IEEE 754 <tt>totalOrder</tt> predicate.
--   
--   Since <a>RealFloat</a> constraint is insufficient to query the sign
--   and payload of NaNs, this function treats all NaNs as positive.
--   
--   Floating-point numbers are ordered as, &lt;math&gt;.
compareByTotalOrder :: RealFloat a => a -> a -> Ordering

-- | Comparison with IEEE 754 <tt>totalOrderMag</tt> predicate.
compareByTotalOrderMag :: RealFloat a => a -> a -> Ordering

-- | Treats NaNs as quiet
classify :: RealFloat a => a -> Class
classifyFloat :: Float -> Class
classifyDouble :: Double -> Class

-- | Similar to <a>realToFrac</a>, but treats NaN, infinities, negative
--   zero even if the rewrite rule is off.
--   
--   The properties of NaN may or may not be kept.
realFloatToFrac :: (RealFloat a, Fractional b) => a -> b
integerToIntMaybe :: Integer -> Maybe Int
naturalToWordMaybe :: Natural -> Maybe Word
unsafeShiftLInteger :: Integer -> Int -> Integer
unsafeShiftRInteger :: Integer -> Int -> Integer

-- | Assumption: <tt>n &gt; 0</tt>, <tt>e &gt;= 0</tt>, and <tt>integerLog2
--   n &gt;= e</tt>
--   
--   Returns <tt>compare (n `<a>rem</a>` 2^(e+1)) (2^e)</tt>.
roundingMode :: Integer -> Int -> Ordering

-- | <a>Integer</a> version of <a>countTrailingZeros</a>. The argument must
--   not be zero.
--   
--   <pre>
--   \(NonZero x) -&gt; countTrailingZerosInteger (toInteger x) === countTrailingZeros (x :: Int64)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; countTrailingZerosInteger 7
--   0
--   
--   &gt;&gt;&gt; countTrailingZerosInteger 8
--   3
--   </pre>
countTrailingZerosInteger :: Integer -> Int

-- | Returns <tt>Just (integerLog2 x)</tt> if the argument <tt>x</tt> is a
--   power of 2, and <tt>Nothing</tt> otherwise. The argument <tt>x</tt>
--   must be strictly positive.
integerIsPowerOf2 :: Integer -> Maybe Int

-- | Returns <tt>(integerLog2 x, isJust (integerIsPowerOf2 x))</tt>. The
--   argument <tt>x</tt> must be strictly positive.
integerLog2IsPowerOf2 :: Integer -> (Int, Bool)

-- | IEEE 754 <tt>minimum</tt> operation. <tt>-0</tt> is smaller than
--   <tt>+0</tt>. Propagates NaNs.
minimum' :: RealFloat a => a -> a -> a

-- | IEEE 754 <tt>minimumNumber</tt> operation. <tt>-0</tt> is smaller than
--   <tt>+0</tt>. Treats NaNs as missing data.
minimumNumber :: RealFloat a => a -> a -> a

-- | IEEE 754 <tt>maximum</tt> operation. <tt>-0</tt> is smaller than
--   <tt>+0</tt>. Propagates NaNs.
maximum' :: RealFloat a => a -> a -> a

-- | IEEE 754 <tt>maximumNumber</tt> operation. <tt>-0</tt> is smaller than
--   <tt>+0</tt>. Treats NaNs as missing data.
maximumNumber :: RealFloat a => a -> a -> a

-- | IEEE 754 <tt>minimumMagnitude</tt> operation.
minimumMagnitude :: RealFloat a => a -> a -> a

-- | IEEE 754 <tt>minimumMagnitudeNumber</tt> operation.
minimumMagnitudeNumber :: RealFloat a => a -> a -> a

-- | IEEE 754 <tt>maximumMagnitude</tt> operation.
maximumMagnitude :: RealFloat a => a -> a -> a

-- | IEEE 754 <tt>maximumMagnitudeNumber</tt> operation.
maximumMagnitudeNumber :: RealFloat a => a -> a -> a

-- | IEEE 754 <tt>nextUp</tt> operation.
--   
--   <pre>
--   nextUp 1 == (0x1.000002p0 :: Float)
--   </pre>
--   
--   <pre>
--   nextUp 1 == (0x1.0000_0000_0000_1p0 :: Double)
--   </pre>
--   
--   <pre>
--   nextUp (1/0) == (1/0 :: Double)
--   </pre>
--   
--   <pre>
--   nextUp (-1/0) == (- maxFinite :: Double)
--   </pre>
--   
--   <pre>
--   nextUp 0 == (0x1p-1074 :: Double)
--   </pre>
--   
--   <pre>
--   nextUp (-0) == (0x1p-1074 :: Double)
--   </pre>
--   
--   <pre>
--   nextUp (-0x1p-1074) == (-0 :: Double)
--   </pre>
--   
--   <pre>
--   isNegativeZero (nextUp (-0x1p-1074) :: Double)
--   </pre>
nextUp :: RealFloat a => a -> a

-- | IEEE 754 <tt>nextDown</tt> operation.
--   
--   <pre>
--   nextDown 1 == (0x1.ffff_ffff_ffff_fp-1 :: Double)
--   </pre>
--   
--   <pre>
--   nextDown 1 == (0x1.fffffep-1 :: Float)
--   </pre>
--   
--   <pre>
--   nextDown (1/0) == (maxFinite :: Double)
--   </pre>
--   
--   <pre>
--   nextDown (-1/0) == (-1/0 :: Double)
--   </pre>
--   
--   <pre>
--   nextDown 0 == (-0x1p-1074 :: Double)
--   </pre>
--   
--   <pre>
--   nextDown (-0) == (-0x1p-1074 :: Double)
--   </pre>
--   
--   <pre>
--   nextDown 0x1p-1074 == (0 :: Double)
--   </pre>
--   
--   <pre>
--   nextDown 0x1p-1022 == (0x0.ffff_ffff_ffff_fp-1022 ::Double)
--   </pre>
nextDown :: RealFloat a => a -> a

-- | <pre>
--   nextTowardZero 1 == (0x1.ffff_ffff_ffff_fp-1 :: Double)
--   </pre>
--   
--   <pre>
--   nextTowardZero 1 == (0x1.fffffep-1 :: Float)
--   </pre>
--   
--   <pre>
--   nextTowardZero (1/0) == (maxFinite :: Double)
--   </pre>
--   
--   <pre>
--   nextTowardZero (-1/0) == (-maxFinite :: Double)
--   </pre>
--   
--   <pre>
--   nextTowardZero 0 == (0 :: Double)
--   </pre>
--   
--   <pre>
--   isNegativeZero (nextTowardZero (-0 :: Double))
--   </pre>
--   
--   <pre>
--   nextTowardZero 0x1p-1074 == (0 :: Double)
--   </pre>
nextTowardZero :: RealFloat a => a -> a
nextUp_positive :: RealFloat a => a -> a
nextDown_positive :: RealFloat a => a -> a

-- | <pre>
--   nextUpFloat 1 == 0x1.000002p0
--   </pre>
--   
--   <pre>
--   nextUpFloat (1/0) == 1/0
--   </pre>
--   
--   <pre>
--   nextUpFloat (-1/0) == - maxFinite
--   </pre>
--   
--   <pre>
--   nextUpFloat 0 == 0x1p-149
--   </pre>
--   
--   <pre>
--   nextUpFloat (-0) == 0x1p-149
--   </pre>
--   
--   <pre>
--   isNegativeZero (nextUpFloat (-0x1p-149))
--   </pre>
nextUpFloat :: Float -> Float

-- | <pre>
--   nextUpDouble 1 == 0x1.0000_0000_0000_1p0
--   </pre>
--   
--   <pre>
--   nextUpDouble (1/0) == 1/0
--   </pre>
--   
--   <pre>
--   nextUpDouble (-1/0) == - maxFinite
--   </pre>
--   
--   <pre>
--   nextUpDouble 0 == 0x1p-1074
--   </pre>
--   
--   <pre>
--   nextUpDouble (-0) == 0x1p-1074
--   </pre>
--   
--   <pre>
--   isNegativeZero (nextUpDouble (-0x1p-1074))
--   </pre>
nextUpDouble :: Double -> Double

-- | <pre>
--   nextDownFloat 1 == 0x1.fffffep-1
--   </pre>
--   
--   <pre>
--   nextDownFloat (1/0) == maxFinite
--   </pre>
--   
--   <pre>
--   nextDownFloat (-1/0) == -1/0
--   </pre>
--   
--   <pre>
--   nextDownFloat 0 == -0x1p-149
--   </pre>
--   
--   <pre>
--   nextDownFloat (-0) == -0x1p-149
--   </pre>
--   
--   <pre>
--   nextDownFloat 0x1p-149 == 0
--   </pre>
nextDownFloat :: Float -> Float

-- | <pre>
--   nextDownDouble 1 == 0x1.ffff_ffff_ffff_fp-1
--   </pre>
--   
--   <pre>
--   nextDownDouble (1/0) == maxFinite
--   </pre>
--   
--   <pre>
--   nextDownDouble (-1/0) == -1/0
--   </pre>
--   
--   <pre>
--   nextDownDouble 0 == -0x1p-1074
--   </pre>
--   
--   <pre>
--   nextDownDouble (-0) == -0x1p-1074
--   </pre>
--   
--   <pre>
--   nextDownDouble 0x1p-1074 == 0
--   </pre>
nextDownDouble :: Double -> Double

-- | <pre>
--   nextTowardZeroFloat 1 == 0x1.fffffep-1
--   </pre>
--   
--   <pre>
--   nextTowardZeroFloat (-1) == -0x1.fffffep-1
--   </pre>
--   
--   <pre>
--   nextTowardZeroFloat (1/0) == maxFinite
--   </pre>
--   
--   <pre>
--   nextTowardZeroFloat (-1/0) == -maxFinite
--   </pre>
--   
--   <pre>
--   nextTowardZeroFloat 0 == 0
--   </pre>
--   
--   <pre>
--   isNegativeZero (nextTowardZeroFloat (-0))
--   </pre>
--   
--   <pre>
--   nextTowardZeroFloat 0x1p-149 == 0
--   </pre>
nextTowardZeroFloat :: Float -> Float

-- | <pre>
--   nextTowardZeroDouble 1 == 0x1.ffff_ffff_ffff_fp-1
--   </pre>
--   
--   <pre>
--   nextTowardZeroDouble (-1) == -0x1.ffff_ffff_ffff_fp-1
--   </pre>
--   
--   <pre>
--   nextTowardZeroDouble (1/0) == maxFinite
--   </pre>
--   
--   <pre>
--   nextTowardZeroDouble (-1/0) == -maxFinite
--   </pre>
--   
--   <pre>
--   nextTowardZeroDouble 0 == 0
--   </pre>
--   
--   <pre>
--   isNegativeZero (nextTowardZeroDouble (-0))
--   </pre>
--   
--   <pre>
--   nextTowardZeroDouble 0x1p-1074 == 0
--   </pre>
nextTowardZeroDouble :: Double -> Double

-- | IEEE 754 <tt>remainder</tt> operation.
remainder :: RealFloat a => a -> a -> a

-- | IEEE 754 <tt>roundToIntegralTiesToEven</tt> operation.
--   
--   <pre>
--   \(x :: Double) -&gt; isFinite x ==&gt; (round' x == fromInteger (round x))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; round' (-0.5)
--   -0.0
--   </pre>
round' :: RealFloat a => a -> a

-- | IEEE 754 <tt>roundToIntegralTiesToAway</tt> operation.
--   
--   <pre>
--   \(x :: Double) -&gt; isFinite x ==&gt; roundAway' x == fromInteger (roundAway x)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; roundAway' (-0.5)
--   -1.0
--   
--   &gt;&gt;&gt; roundAway' (-0.4)
--   -0.0
--   </pre>
roundAway' :: RealFloat a => a -> a

-- | IEEE 754 <tt>roundToIntegralTowardZero</tt> operation.
--   
--   <pre>
--   \(x :: Double) -&gt; isFinite x ==&gt; truncate' x == fromInteger (truncate x)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; truncate' (-0.5)
--   -0.0
--   </pre>
truncate' :: RealFloat a => a -> a

-- | IEEE 754 <tt>roundToIntegralTowardPositive</tt> operation.
--   
--   <pre>
--   \(x :: Double) -&gt; isFinite x ==&gt; ceiling' x == fromInteger (ceiling x)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ceiling' (-0.8)
--   -0.0
--   
--   &gt;&gt;&gt; ceiling' (-0.5)
--   -0.0
--   </pre>
ceiling' :: RealFloat a => a -> a

-- | IEEE 754 <tt>roundToIntegralTowardNegative</tt> operation.
--   
--   <pre>
--   \(x :: Double) -&gt; isFinite x ==&gt; floor' x == fromInteger (floor x)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; floor' (-0.1)
--   -1.0
--   
--   &gt;&gt;&gt; floor' (-0)
--   -0.0
--   </pre>
floor' :: RealFloat a => a -> a

-- | IEEE 754 <tt>convertToIntegerTiesToAway</tt> operation.
--   
--   <pre>
--   &gt;&gt;&gt; roundAway 4.5
--   5
--   </pre>
roundAway :: (RealFrac a, Integral b) => a -> b
newtype RoundTowardZero a
RoundTowardZero :: a -> RoundTowardZero a
[roundTowardZero] :: RoundTowardZero a -> a
newtype RoundTowardNegative a
RoundTowardNegative :: a -> RoundTowardNegative a
[roundTowardNegative] :: RoundTowardNegative a -> a
newtype RoundTowardPositive a
RoundTowardPositive :: a -> RoundTowardPositive a
[roundTowardPositive] :: RoundTowardPositive a -> a
newtype RoundTiesToAway a
RoundTiesToAway :: a -> RoundTiesToAway a
[roundTiesToAway] :: RoundTiesToAway a -> a
newtype RoundTiesToEven a
RoundTiesToEven :: a -> RoundTiesToEven a
[roundTiesToEven] :: RoundTiesToEven a -> a
class Functor f => RoundingStrategy f
exact :: RoundingStrategy f => a -> f a
inexact :: RoundingStrategy f => Ordering -> Bool -> Int -> a -> a -> f a
doRound :: RoundingStrategy f => Bool -> Ordering -> Bool -> Int -> a -> a -> f a
quotRemByExpt :: Integer -> Integer -> Int -> (Integer, Integer)
multiplyByExpt :: Integer -> Integer -> Int -> Integer
isDivisibleByExpt :: Integer -> Integer -> Int -> Integer -> Bool

-- | Assumption: <tt>n &gt;= 0</tt>, <tt>e &gt;= 0</tt>, and <tt>r == n
--   `<a>rem</a>` base^(e+1)</tt>
--   
--   Returns <tt>compare r (base^e)</tt>.
compareWithExpt :: Integer -> Integer -> Integer -> Int -> Ordering
fromIntegerR :: (RealFloat a, RoundingStrategy f) => Integer -> f a
fromIntegralR :: (Integral i, RealFloat a, RoundingStrategy f) => i -> f a
fromIntegralRBits :: (Integral i, Bits i, RealFloat a, RoundingStrategy f) => i -> f a

-- | <pre>
--   &gt;&gt;&gt; boundsForExactConversion (Proxy :: Proxy Double) :: (Maybe Integer, Maybe Integer) -- (Just (-2^53),Just (2^53))
--   (Just (-9007199254740992),Just 9007199254740992)
--   
--   &gt;&gt;&gt; boundsForExactConversion (Proxy :: Proxy Double) :: (Maybe Int32, Maybe Int32) -- the conversion is always exact
--   (Nothing,Nothing)
--   
--   &gt;&gt;&gt; boundsForExactConversion (Proxy :: Proxy Float) :: (Maybe Word, Maybe Word) -- (Nothing,Just (2^24))
--   (Nothing,Just 16777216)
--   </pre>
boundsForExactConversion :: (Integral i, Bits i, RealFloat a) => Proxy a -> (Maybe i, Maybe i)
minBoundAsInteger :: Bits i => i -> Maybe Integer
maxBoundAsInteger :: Bits i => i -> Maybe Integer
positiveWordToBinaryFloatR :: (RealFloat a, RoundingStrategy f) => Bool -> Word -> f a
positiveWordToBinaryFloatR# :: (RealFloat a, RoundingStrategy f) => Bool -> Word# -> f a
fromPositiveIntegerR :: (RealFloat a, RoundingStrategy f) => Bool -> Integer -> f a
fromRationalR :: (RealFloat a, RoundingStrategy f) => Rational -> f a
fromRatioR :: (RealFloat a, RoundingStrategy f) => Integer -> Integer -> f a
fromPositiveRatioR :: (RealFloat a, RoundingStrategy f) => Bool -> Integer -> Integer -> f a
encodeFloatR :: (RealFloat a, RoundingStrategy f) => Integer -> Int -> f a
encodePositiveFloatR :: (RealFloat a, RoundingStrategy f) => Bool -> Integer -> Int -> f a
encodePositiveFloatR# :: (RealFloat a, RoundingStrategy f) => Bool -> Integer -> Int# -> f a
fusedMultiplyAddDouble :: Double -> Double -> Double -> Double
fusedMultiplyAddFloat :: Float -> Float -> Float -> Float
isMantissaEven :: RealFloat a => a -> Bool

-- | Returns <tt>x := a + b</tt> and <tt>x - &lt;the exact value of (a +
--   b)&gt;</tt>.
--   
--   This function does not avoid undue overflow; For example, the second
--   component of <tt>twoSum (0x1.017bd555b0b1fp1022)
--   (-0x1.fffffffffffffp1023)</tt> is a NaN.
--   
--   <pre>
--   \(a :: Double) (b :: Double) -&gt; let (_,expMax) = floatRange a in max (exponent a) (exponent b) &lt; expMax ==&gt; let (x, y) = twoSum a b in a + b == x &amp;&amp; toRational a + toRational b == toRational x + toRational y
--   </pre>
twoSum :: RealFloat a => a -> a -> (a, a)

-- | Addition, with round to nearest odd floating-point number. Like
--   <a>twoSum</a>, this function does not handle undue overflow.
add_roundToOdd :: RealFloat a => a -> a -> a
split :: RealFloat a => a -> (a, a)
twoProduct_generic :: RealFloat a => a -> a -> (a, a)
twoProductFloat_viaDouble :: Float -> Float -> (Float, Float)

-- | <pre>
--   \(a :: Double) (b :: Double) -&gt; let (x, y) = twoProduct a b in a * b == x &amp;&amp; fromRational (toRational a * toRational b - toRational x) == y
--   </pre>
twoProduct :: RealFloat a => a -> a -> (a, a)
twoProduct_nonscaling :: RealFloat a => a -> a -> (a, a)
twoProductFloat :: Float -> Float -> (Float, Float)
twoProductDouble :: Double -> Double -> (Double, Double)
fusedMultiplyAdd_twoProduct :: RealFloat a => a -> a -> a -> a
fusedMultiplyAddFloat_viaDouble :: Float -> Float -> Float -> Float
fusedMultiplyAdd_viaInteger :: RealFloat a => a -> a -> a -> a
fusedMultiplyAdd_viaRational :: RealFloat a => a -> a -> a -> a

-- | IEEE 754 <tt>fusedMultiplyAdd</tt> operation.
--   
--   May make use of hardware FMA instructions if the target architecture
--   has it; set <tt>fma3</tt> package flag on x86 systems.
--   
--   <pre>
--   \(a :: Double) (b :: Double) (c :: Double) -&gt; fusedMultiplyAdd a b c == fromRational (toRational a * toRational b + toRational c)
--   </pre>
fusedMultiplyAdd :: RealFloat a => a -> a -> a -> a
castHalfToWord16 :: Half -> Word16
castWord16ToHalf :: Word16 -> Half
nextUpHalf :: Half -> Half
nextDownHalf :: Half -> Half
nextTowardZeroHalf :: Half -> Half
isNormalHalf :: Half -> Bool
isFiniteHalf :: Half -> Bool
isSignMinusHalf :: Half -> Bool
classifyHalf :: Half -> Class
classifyHalfNaNAware :: Half -> Class
compareByTotalOrderHalfNaNAware :: Half -> Half -> Ordering
halfToFloat :: Half -> Float
halfToDouble :: Half -> Double
floatToHalf :: Float -> Half
doubleToHalf :: Double -> Half

-- | IEEE 754 <tt>addition</tt> operation.
genericAdd :: (RealFloat a, RealFloat b) => a -> a -> b
infixl 6 `genericAdd`

-- | IEEE 754 <tt>subtraction</tt> operation.
genericSub :: (RealFloat a, RealFloat b) => a -> a -> b
infixl 6 `genericSub`

-- | IEEE 754 <tt>multiplication</tt> operation.
genericMul :: (RealFloat a, RealFloat b) => a -> a -> b
infixl 7 `genericMul`

-- | IEEE 754 <tt>division</tt> operation.
genericDiv :: (RealFloat a, RealFloat b) => a -> a -> b
infixl 7 `genericDiv`

-- | IEEE 754 <tt>fusedMultiplyAdd</tt> operation.
genericFusedMultiplyAdd :: (RealFloat a, RealFloat b) => a -> a -> a -> b

-- | Returns True if <tt>a</tt> is a subtype of <tt>b</tt>
--   
--   <pre>
--   &gt;&gt;&gt; isSubFloatingType (undefined :: Float) (undefined :: Double)
--   True
--   
--   &gt;&gt;&gt; isSubFloatingType (undefined :: Double) (undefined :: Float)
--   False
--   
--   &gt;&gt;&gt; isSubFloatingType (undefined :: Double) (undefined :: Double)
--   True
--   </pre>
isSubFloatingType :: (RealFloat a, RealFloat b) => a -> b -> Bool

-- | Returns True if <tt>a</tt> is a subtype of <tt>b</tt>
--   
--   <pre>
--   &gt;&gt;&gt; isSubFloatingTypeProxy (Proxy :: Proxy Float) (Proxy :: Proxy Double)
--   True
--   
--   &gt;&gt;&gt; isSubFloatingTypeProxy (Proxy :: Proxy Double) (Proxy :: Proxy Float)
--   False
--   
--   &gt;&gt;&gt; isSubFloatingTypeProxy (Proxy :: Proxy Double) (Proxy :: Proxy Double)
--   True
--   </pre>
isSubFloatingTypeProxy :: (RealFloat a, RealFloat b) => Proxy a -> Proxy b -> Bool
newtype RoundTiesTowardZero a
RoundTiesTowardZero :: a -> RoundTiesTowardZero a
[roundTiesTowardZero] :: RoundTiesTowardZero a -> a

-- | IEEE 754 <tt>augmentedAddition</tt> operation.
augmentedAddition :: RealFloat a => a -> a -> (a, a)

-- | IEEE 754 <tt>augmentedSubtraction</tt> operation.
augmentedSubtraction :: RealFloat a => a -> a -> (a, a)

-- | IEEE 754 <tt>augmentedMultiplication</tt> operation.
augmentedMultiplication :: RealFloat a => a -> a -> (a, a)
augmentedAddition_viaRational :: (RealFloat a, Show a) => a -> a -> (a, a)
augmentedMultiplication_viaRational :: (RealFloat a, Show a) => a -> a -> (a, a)


-- | This module provides IEEE 754-compliant operations for floating-point
--   numbers.
--   
--   The functions in this module assume that the given floating-point type
--   conform to IEEE 754 format.
--   
--   Since <a>RealFloat</a> constraint is insufficient to query properties
--   of a NaN, the functions here assumes all NaN as positive, quiet. If
--   you want better treatment for NaNs, use the module
--   <a>Numeric.Floating.IEEE.NaN</a>.
--   
--   Since floating-point exceptions cannot be accessed from Haskell in
--   normal way, the operations provided by this module ignore exceptional
--   behavior. Don't let fp exceptions trap.
--   
--   On i386 target, you may need to set <tt>-msse2</tt> option to get
--   correct floating-point behavior.
module Numeric.Floating.IEEE

-- | IEEE 754 <tt>roundToIntegralTiesToEven</tt> operation.
--   
--   <pre>
--   \(x :: Double) -&gt; isFinite x ==&gt; (round' x == fromInteger (round x))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; round' (-0.5)
--   -0.0
--   </pre>
round' :: RealFloat a => a -> a

-- | IEEE 754 <tt>roundToIntegralTiesToAway</tt> operation.
--   
--   <pre>
--   \(x :: Double) -&gt; isFinite x ==&gt; roundAway' x == fromInteger (roundAway x)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; roundAway' (-0.5)
--   -1.0
--   
--   &gt;&gt;&gt; roundAway' (-0.4)
--   -0.0
--   </pre>
roundAway' :: RealFloat a => a -> a

-- | IEEE 754 <tt>roundToIntegralTowardZero</tt> operation.
--   
--   <pre>
--   \(x :: Double) -&gt; isFinite x ==&gt; truncate' x == fromInteger (truncate x)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; truncate' (-0.5)
--   -0.0
--   </pre>
truncate' :: RealFloat a => a -> a

-- | IEEE 754 <tt>roundToIntegralTowardPositive</tt> operation.
--   
--   <pre>
--   \(x :: Double) -&gt; isFinite x ==&gt; ceiling' x == fromInteger (ceiling x)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ceiling' (-0.8)
--   -0.0
--   
--   &gt;&gt;&gt; ceiling' (-0.5)
--   -0.0
--   </pre>
ceiling' :: RealFloat a => a -> a

-- | IEEE 754 <tt>roundToIntegralTowardNegative</tt> operation.
--   
--   <pre>
--   \(x :: Double) -&gt; isFinite x ==&gt; floor' x == fromInteger (floor x)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; floor' (-0.1)
--   -1.0
--   
--   &gt;&gt;&gt; floor' (-0)
--   -0.0
--   </pre>
floor' :: RealFloat a => a -> a

-- | IEEE 754 <tt>nextUp</tt> operation.
--   
--   <pre>
--   nextUp 1 == (0x1.000002p0 :: Float)
--   </pre>
--   
--   <pre>
--   nextUp 1 == (0x1.0000_0000_0000_1p0 :: Double)
--   </pre>
--   
--   <pre>
--   nextUp (1/0) == (1/0 :: Double)
--   </pre>
--   
--   <pre>
--   nextUp (-1/0) == (- maxFinite :: Double)
--   </pre>
--   
--   <pre>
--   nextUp 0 == (0x1p-1074 :: Double)
--   </pre>
--   
--   <pre>
--   nextUp (-0) == (0x1p-1074 :: Double)
--   </pre>
--   
--   <pre>
--   nextUp (-0x1p-1074) == (-0 :: Double)
--   </pre>
--   
--   <pre>
--   isNegativeZero (nextUp (-0x1p-1074) :: Double)
--   </pre>
nextUp :: RealFloat a => a -> a

-- | IEEE 754 <tt>nextDown</tt> operation.
--   
--   <pre>
--   nextDown 1 == (0x1.ffff_ffff_ffff_fp-1 :: Double)
--   </pre>
--   
--   <pre>
--   nextDown 1 == (0x1.fffffep-1 :: Float)
--   </pre>
--   
--   <pre>
--   nextDown (1/0) == (maxFinite :: Double)
--   </pre>
--   
--   <pre>
--   nextDown (-1/0) == (-1/0 :: Double)
--   </pre>
--   
--   <pre>
--   nextDown 0 == (-0x1p-1074 :: Double)
--   </pre>
--   
--   <pre>
--   nextDown (-0) == (-0x1p-1074 :: Double)
--   </pre>
--   
--   <pre>
--   nextDown 0x1p-1074 == (0 :: Double)
--   </pre>
--   
--   <pre>
--   nextDown 0x1p-1022 == (0x0.ffff_ffff_ffff_fp-1022 ::Double)
--   </pre>
nextDown :: RealFloat a => a -> a

-- | <pre>
--   nextTowardZero 1 == (0x1.ffff_ffff_ffff_fp-1 :: Double)
--   </pre>
--   
--   <pre>
--   nextTowardZero 1 == (0x1.fffffep-1 :: Float)
--   </pre>
--   
--   <pre>
--   nextTowardZero (1/0) == (maxFinite :: Double)
--   </pre>
--   
--   <pre>
--   nextTowardZero (-1/0) == (-maxFinite :: Double)
--   </pre>
--   
--   <pre>
--   nextTowardZero 0 == (0 :: Double)
--   </pre>
--   
--   <pre>
--   isNegativeZero (nextTowardZero (-0 :: Double))
--   </pre>
--   
--   <pre>
--   nextTowardZero 0x1p-1074 == (0 :: Double)
--   </pre>
nextTowardZero :: RealFloat a => a -> a

-- | IEEE 754 <tt>remainder</tt> operation.
remainder :: RealFloat a => a -> a -> a

-- | multiplies a floating-point number by an integer power of the radix
scaleFloat :: RealFloat a => Int -> a -> a
(+) :: Num a => a -> a -> a
infixl 6 +
(-) :: Num a => a -> a -> a
infixl 6 -
(*) :: Num a => a -> a -> a
infixl 7 *

-- | Fractional division.
(/) :: Fractional a => a -> a -> a
infixl 7 /
sqrt :: Floating a => a -> a

-- | IEEE 754 <tt>fusedMultiplyAdd</tt> operation.
--   
--   May make use of hardware FMA instructions if the target architecture
--   has it; set <tt>fma3</tt> package flag on x86 systems.
--   
--   <pre>
--   \(a :: Double) (b :: Double) (c :: Double) -&gt; fusedMultiplyAdd a b c == fromRational (toRational a * toRational b + toRational c)
--   </pre>
fusedMultiplyAdd :: RealFloat a => a -> a -> a -> a

-- | IEEE 754 <tt>addition</tt> operation.
genericAdd :: (RealFloat a, RealFloat b) => a -> a -> b
infixl 6 `genericAdd`

-- | IEEE 754 <tt>subtraction</tt> operation.
genericSub :: (RealFloat a, RealFloat b) => a -> a -> b
infixl 6 `genericSub`

-- | IEEE 754 <tt>multiplication</tt> operation.
genericMul :: (RealFloat a, RealFloat b) => a -> a -> b
infixl 7 `genericMul`

-- | IEEE 754 <tt>division</tt> operation.
genericDiv :: (RealFloat a, RealFloat b) => a -> a -> b
infixl 7 `genericDiv`

-- | IEEE 754 <tt>fusedMultiplyAdd</tt> operation.
genericFusedMultiplyAdd :: (RealFloat a, RealFloat b) => a -> a -> a -> b

-- | IEEE 754 <tt>convertFromInt</tt> operation, with each rounding
--   attributes.
fromIntegerTiesToEven :: RealFloat a => Integer -> a

-- | IEEE 754 <tt>convertFromInt</tt> operation, with each rounding
--   attributes.
fromIntegerTiesToAway :: RealFloat a => Integer -> a

-- | IEEE 754 <tt>convertFromInt</tt> operation, with each rounding
--   attributes.
fromIntegerTowardPositive :: RealFloat a => Integer -> a

-- | IEEE 754 <tt>convertFromInt</tt> operation, with each rounding
--   attributes.
fromIntegerTowardNegative :: RealFloat a => Integer -> a

-- | IEEE 754 <tt>convertFromInt</tt> operation, with each rounding
--   attributes.
fromIntegerTowardZero :: RealFloat a => Integer -> a

-- | IEEE 754 <tt>convertFromInt</tt> operation, with each rounding
--   attributes.
fromIntegralTiesToEven :: (Integral i, RealFloat a) => i -> a

-- | IEEE 754 <tt>convertFromInt</tt> operation, with each rounding
--   attributes.
fromIntegralTiesToAway :: (Integral i, RealFloat a) => i -> a

-- | IEEE 754 <tt>convertFromInt</tt> operation, with each rounding
--   attributes.
fromIntegralTowardPositive :: (Integral i, RealFloat a) => i -> a

-- | IEEE 754 <tt>convertFromInt</tt> operation, with each rounding
--   attributes.
fromIntegralTowardNegative :: (Integral i, RealFloat a) => i -> a

-- | IEEE 754 <tt>convertFromInt</tt> operation, with each rounding
--   attributes.
fromIntegralTowardZero :: (Integral i, RealFloat a) => i -> a
fromRationalTiesToEven :: RealFloat a => Rational -> a
fromRationalTiesToAway :: RealFloat a => Rational -> a
fromRationalTowardPositive :: RealFloat a => Rational -> a
fromRationalTowardNegative :: RealFloat a => Rational -> a
fromRationalTowardZero :: RealFloat a => Rational -> a

-- | <tt><a>round</a> x</tt> returns the nearest integer to <tt>x</tt>; the
--   even integer if <tt>x</tt> is equidistant between two integers
round :: (RealFrac a, Integral b) => a -> b

-- | IEEE 754 <tt>convertToIntegerTiesToAway</tt> operation.
--   
--   <pre>
--   &gt;&gt;&gt; roundAway 4.5
--   5
--   </pre>
roundAway :: (RealFrac a, Integral b) => a -> b

-- | <tt><a>truncate</a> x</tt> returns the integer nearest <tt>x</tt>
--   between zero and <tt>x</tt>
truncate :: (RealFrac a, Integral b) => a -> b

-- | <tt><a>ceiling</a> x</tt> returns the least integer not less than
--   <tt>x</tt>
ceiling :: (RealFrac a, Integral b) => a -> b

-- | <tt><a>floor</a> x</tt> returns the greatest integer not greater than
--   <tt>x</tt>
floor :: (RealFrac a, Integral b) => a -> b

-- | Similar to <a>realToFrac</a>, but treats NaN, infinities, negative
--   zero even if the rewrite rule is off.
--   
--   The properties of NaN may or may not be kept.
realFloatToFrac :: (RealFloat a, Fractional b) => a -> b

-- | Unary negation.
negate :: Num a => a -> a

-- | Absolute value.
abs :: Num a => a -> a
data Class
SignalingNaN :: Class
QuietNaN :: Class
NegativeInfinity :: Class
NegativeNormal :: Class
NegativeSubnormal :: Class
NegativeZero :: Class
PositiveZero :: Class
PositiveSubnormal :: Class
PositiveNormal :: Class
PositiveInfinity :: Class

-- | Treats NaNs as quiet
classify :: RealFloat a => a -> Class

-- | IEEE 754 <tt>isSignMinus</tt> operation.
--   
--   Since <a>RealFloat</a> constraint is insufficient to query the sign of
--   NaNs, this function treats all NaNs as positive.
isSignMinus :: RealFloat a => a -> Bool

-- | IEEE 754 <tt>isNormal</tt> operation.
isNormal :: RealFloat a => a -> Bool

-- | IEEE 754 <tt>isFinite</tt> operation.
isFinite :: RealFloat a => a -> Bool

-- | IEEE 754 <tt>isZero</tt> operation.
isZero :: RealFloat a => a -> Bool

-- | <a>True</a> if the argument is too small to be represented in
--   normalized format
isDenormalized :: RealFloat a => a -> Bool

-- | <a>True</a> if the argument is an IEEE infinity or negative infinity
isInfinite :: RealFloat a => a -> Bool

-- | <a>True</a> if the argument is an IEEE "not-a-number" (NaN) value
isNaN :: RealFloat a => a -> Bool

-- | a constant function, returning the radix of the representation (often
--   <tt>2</tt>)
floatRadix :: RealFloat a => a -> Integer

-- | Comparison with IEEE 754 <tt>totalOrder</tt> predicate.
--   
--   Since <a>RealFloat</a> constraint is insufficient to query the sign
--   and payload of NaNs, this function treats all NaNs as positive.
--   
--   Floating-point numbers are ordered as, &lt;math&gt;.
compareByTotalOrder :: RealFloat a => a -> a -> Ordering

-- | Comparison with IEEE 754 <tt>totalOrderMag</tt> predicate.
compareByTotalOrderMag :: RealFloat a => a -> a -> Ordering

-- | IEEE 754 <tt>augmentedAddition</tt> operation.
augmentedAddition :: RealFloat a => a -> a -> (a, a)

-- | IEEE 754 <tt>augmentedSubtraction</tt> operation.
augmentedSubtraction :: RealFloat a => a -> a -> (a, a)

-- | IEEE 754 <tt>augmentedMultiplication</tt> operation.
augmentedMultiplication :: RealFloat a => a -> a -> (a, a)

-- | IEEE 754 <tt>minimum</tt> operation. <tt>-0</tt> is smaller than
--   <tt>+0</tt>. Propagates NaNs.
minimum' :: RealFloat a => a -> a -> a

-- | IEEE 754 <tt>minimumNumber</tt> operation. <tt>-0</tt> is smaller than
--   <tt>+0</tt>. Treats NaNs as missing data.
minimumNumber :: RealFloat a => a -> a -> a

-- | IEEE 754 <tt>maximum</tt> operation. <tt>-0</tt> is smaller than
--   <tt>+0</tt>. Propagates NaNs.
maximum' :: RealFloat a => a -> a -> a

-- | IEEE 754 <tt>maximumNumber</tt> operation. <tt>-0</tt> is smaller than
--   <tt>+0</tt>. Treats NaNs as missing data.
maximumNumber :: RealFloat a => a -> a -> a

-- | IEEE 754 <tt>minimumMagnitude</tt> operation.
minimumMagnitude :: RealFloat a => a -> a -> a

-- | IEEE 754 <tt>minimumMagnitudeNumber</tt> operation.
minimumMagnitudeNumber :: RealFloat a => a -> a -> a

-- | IEEE 754 <tt>maximumMagnitude</tt> operation.
maximumMagnitude :: RealFloat a => a -> a -> a

-- | IEEE 754 <tt>maximumMagnitudeNumber</tt> operation.
maximumMagnitudeNumber :: RealFloat a => a -> a -> a

-- | <pre>
--   (minPositive :: Float) == 0x1p-149
--   </pre>
--   
--   <pre>
--   (minPositive :: Double) == 0x1p-1074
--   </pre>
--   
--   <pre>
--   nextDown (minPositive :: Float) == 0
--   </pre>
--   
--   <pre>
--   nextDown (minPositive :: Double) == 0
--   </pre>
minPositive :: RealFloat a => a

-- | <pre>
--   (minPositiveNormal :: Float) == 0x1p-126
--   </pre>
--   
--   <pre>
--   (minPositiveNormal :: Double) == 0x1p-1022
--   </pre>
--   
--   <pre>
--   not (isDenormalized (minPositiveNormal :: Float))
--   </pre>
--   
--   <pre>
--   not (isDenormalized (minPositiveNormal :: Double))
--   </pre>
--   
--   <pre>
--   isDenormalized (nextDown (minPositiveNormal :: Float))
--   </pre>
--   
--   <pre>
--   isDenormalized (nextDown (minPositiveNormal :: Double))
--   </pre>
minPositiveNormal :: RealFloat a => a

-- | <pre>
--   (maxFinite :: Float) == 0x1.fffffep+127
--   </pre>
--   
--   <pre>
--   (maxFinite :: Double) == 0x1.ffff_ffff_ffff_fp+1023
--   </pre>
maxFinite :: RealFloat a => a

module Numeric.Floating.IEEE.NaN

-- | An instance of this class supports manipulation of NaN.
class SupportsNaN a

-- | Returns the first operand, with the sign of the second
--   
--   IEEE 754 <tt>copySign</tt> operation.
copySign :: SupportsNaN a => a -> a -> a

-- | IEEE 754 <tt>isSignMinus</tt> operation.
isSignMinus :: SupportsNaN a => a -> Bool

-- | IEEE 754 <tt>isSignaling</tt> operation.
isSignaling :: SupportsNaN a => a -> Bool

-- | IEEE 754 <tt>getPayload</tt> operation.
getPayload :: SupportsNaN a => a -> a

-- | IEEE 754 <tt>setPayload</tt> operation.
setPayload :: SupportsNaN a => a -> a

-- | IEEE 754 <tt>setPayloadSignaling</tt> operation.
setPayloadSignaling :: SupportsNaN a => a -> a
classify :: (RealFloat a, SupportsNaN a) => a -> Class
data Class
SignalingNaN :: Class
QuietNaN :: Class
NegativeInfinity :: Class
NegativeNormal :: Class
NegativeSubnormal :: Class
NegativeZero :: Class
PositiveZero :: Class
PositiveSubnormal :: Class
PositiveNormal :: Class
PositiveInfinity :: Class
newtype TotallyOrdered a
TotallyOrdered :: a -> TotallyOrdered a
compareByTotalOrder :: (RealFloat a, SupportsNaN a) => a -> a -> Ordering

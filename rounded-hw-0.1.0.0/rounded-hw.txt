-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Directed rounding for built-in floating types
--   
--   Please see the README on GitHub at
--   <a>https://github.com/minoki/haskell-floating-point/tree/master/rounded-hw#readme</a>
@package rounded-hw
@version 0.1.0.0

module Numeric.Rounded.Hardware.Backend.ViaRational
newtype ViaRational a
ViaRational :: a -> ViaRational a
instance Foreign.Storable.Storable a => Foreign.Storable.Storable (Numeric.Rounded.Hardware.Backend.ViaRational.ViaRational a)
instance GHC.Num.Num a => GHC.Num.Num (Numeric.Rounded.Hardware.Backend.ViaRational.ViaRational a)
instance GHC.Generics.Generic (Numeric.Rounded.Hardware.Backend.ViaRational.ViaRational a)
instance GHC.Show.Show a => GHC.Show.Show (Numeric.Rounded.Hardware.Backend.ViaRational.ViaRational a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Numeric.Rounded.Hardware.Backend.ViaRational.ViaRational a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Numeric.Rounded.Hardware.Backend.ViaRational.ViaRational a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Numeric.Rounded.Hardware.Backend.ViaRational.ViaRational a)
instance (GHC.Float.RealFloat a, GHC.Num.Num a, Numeric.Rounded.Hardware.Internal.Constants.RealFloatConstants a) => Numeric.Rounded.Hardware.Internal.Class.RoundedRing (Numeric.Rounded.Hardware.Backend.ViaRational.ViaRational a)
instance (GHC.Float.RealFloat a, GHC.Num.Num a, Numeric.Rounded.Hardware.Internal.Constants.RealFloatConstants a) => Numeric.Rounded.Hardware.Internal.Class.RoundedFractional (Numeric.Rounded.Hardware.Backend.ViaRational.ViaRational a)
instance (GHC.Float.RealFloat a, Numeric.Rounded.Hardware.Internal.Constants.RealFloatConstants a) => Numeric.Rounded.Hardware.Internal.Class.RoundedSqrt (Numeric.Rounded.Hardware.Backend.ViaRational.ViaRational a)
instance (GHC.Float.RealFloat a, Numeric.Rounded.Hardware.Internal.Constants.RealFloatConstants a, Foreign.Storable.Storable a) => Numeric.Rounded.Hardware.Internal.Class.RoundedRing_Vector Data.Vector.Storable.Vector (Numeric.Rounded.Hardware.Backend.ViaRational.ViaRational a)
instance (GHC.Float.RealFloat a, Numeric.Rounded.Hardware.Internal.Constants.RealFloatConstants a, Foreign.Storable.Storable a) => Numeric.Rounded.Hardware.Internal.Class.RoundedFractional_Vector Data.Vector.Storable.Vector (Numeric.Rounded.Hardware.Backend.ViaRational.ViaRational a)
instance (GHC.Float.RealFloat a, Numeric.Rounded.Hardware.Internal.Constants.RealFloatConstants a, Foreign.Storable.Storable a) => Numeric.Rounded.Hardware.Internal.Class.RoundedSqrt_Vector Data.Vector.Storable.Vector (Numeric.Rounded.Hardware.Backend.ViaRational.ViaRational a)
instance (GHC.Float.RealFloat a, Numeric.Rounded.Hardware.Internal.Constants.RealFloatConstants a, Data.Vector.Unboxed.Base.Unbox a) => Numeric.Rounded.Hardware.Internal.Class.RoundedRing_Vector Data.Vector.Unboxed.Base.Vector (Numeric.Rounded.Hardware.Backend.ViaRational.ViaRational a)
instance (GHC.Float.RealFloat a, Numeric.Rounded.Hardware.Internal.Constants.RealFloatConstants a, Data.Vector.Unboxed.Base.Unbox a) => Numeric.Rounded.Hardware.Internal.Class.RoundedFractional_Vector Data.Vector.Unboxed.Base.Vector (Numeric.Rounded.Hardware.Backend.ViaRational.ViaRational a)
instance (GHC.Float.RealFloat a, Numeric.Rounded.Hardware.Internal.Constants.RealFloatConstants a, Data.Vector.Unboxed.Base.Unbox a) => Numeric.Rounded.Hardware.Internal.Class.RoundedSqrt_Vector Data.Vector.Unboxed.Base.Vector (Numeric.Rounded.Hardware.Backend.ViaRational.ViaRational a)
instance Data.Vector.Unboxed.Base.Unbox a => Data.Vector.Generic.Mutable.Base.MVector Data.Vector.Unboxed.Base.MVector (Numeric.Rounded.Hardware.Backend.ViaRational.ViaRational a)
instance Data.Vector.Unboxed.Base.Unbox a => Data.Vector.Generic.Base.Vector Data.Vector.Unboxed.Base.Vector (Numeric.Rounded.Hardware.Backend.ViaRational.ViaRational a)
instance Data.Vector.Unboxed.Base.Unbox a => Data.Vector.Unboxed.Base.Unbox (Numeric.Rounded.Hardware.Backend.ViaRational.ViaRational a)


-- | The types in this module implements rounding-mode-controlled
--   operations in C.
--   
--   There are several ways to control rounding mode in C, and an
--   appropriate technology will be selected at compile time. This library
--   implements the following options:
--   
--   <ul>
--   <li>C99 <tt>fesetround</tt></li>
--   <li>On x86 systems,<ul><li>SSE2 MXCSR (for <a>Float</a> and
--   <a>Double</a>)</li><li>AVX512 EVEX encoding (for <a>Float</a> and
--   <a>Double</a>)</li><li>x87 Control Word (for
--   <a>LongDouble</a>)</li></ul></li>
--   <li>On AArch64, FPCR</li>
--   </ul>
--   
--   You should not need to import this module directly.
--   
--   This module is not available if the package flag <tt>pure-hs</tt> is
--   set.
module Numeric.Rounded.Hardware.Backend.C

-- | A wrapper providing particular instances for <a>RoundedRing</a>,
--   <a>RoundedFractional</a> and <a>RoundedSqrt</a>.
--   
--   This type is different from <tt>CFloat</tt> from
--   <a>Foreign.C.Types</a>.
newtype CFloat
CFloat :: Float -> CFloat

-- | A wrapper providing particular instances for <a>RoundedRing</a>,
--   <a>RoundedFractional</a> and <a>RoundedSqrt</a>.
--   
--   This type is different from <tt>CDouble</tt> from
--   <a>Foreign.C.Types</a>.
newtype CDouble
CDouble :: Double -> CDouble
data family MVector s a
data family Vector a
roundedFloatFromInt64 :: RoundingMode -> Int64 -> Float
roundedFloatFromWord64 :: RoundingMode -> Word64 -> Float
roundedDoubleFromInt64 :: RoundingMode -> Int64 -> Double
roundedDoubleFromWord64 :: RoundingMode -> Word64 -> Double
instance Foreign.Storable.Storable Numeric.Rounded.Hardware.Backend.C.CDouble
instance GHC.Num.Num Numeric.Rounded.Hardware.Backend.C.CDouble
instance GHC.Generics.Generic Numeric.Rounded.Hardware.Backend.C.CDouble
instance GHC.Show.Show Numeric.Rounded.Hardware.Backend.C.CDouble
instance GHC.Classes.Ord Numeric.Rounded.Hardware.Backend.C.CDouble
instance GHC.Classes.Eq Numeric.Rounded.Hardware.Backend.C.CDouble
instance Foreign.Storable.Storable Numeric.Rounded.Hardware.Backend.C.CFloat
instance GHC.Num.Num Numeric.Rounded.Hardware.Backend.C.CFloat
instance GHC.Generics.Generic Numeric.Rounded.Hardware.Backend.C.CFloat
instance GHC.Show.Show Numeric.Rounded.Hardware.Backend.C.CFloat
instance GHC.Classes.Ord Numeric.Rounded.Hardware.Backend.C.CFloat
instance GHC.Classes.Eq Numeric.Rounded.Hardware.Backend.C.CFloat
instance Control.DeepSeq.NFData Numeric.Rounded.Hardware.Backend.C.CDouble
instance Numeric.Rounded.Hardware.Internal.Class.RoundedRing Numeric.Rounded.Hardware.Backend.C.CDouble
instance Numeric.Rounded.Hardware.Internal.Class.RoundedFractional Numeric.Rounded.Hardware.Backend.C.CDouble
instance Numeric.Rounded.Hardware.Internal.Class.RoundedSqrt Numeric.Rounded.Hardware.Backend.C.CDouble
instance Numeric.Rounded.Hardware.Internal.Class.RoundedRing_Vector Data.Vector.Storable.Vector Numeric.Rounded.Hardware.Backend.C.CDouble
instance Numeric.Rounded.Hardware.Internal.Class.RoundedFractional_Vector Data.Vector.Storable.Vector Numeric.Rounded.Hardware.Backend.C.CDouble
instance Numeric.Rounded.Hardware.Internal.Class.RoundedSqrt_Vector Data.Vector.Storable.Vector Numeric.Rounded.Hardware.Backend.C.CDouble
instance Numeric.Rounded.Hardware.Internal.Class.RoundedRing_Vector Data.Vector.Unboxed.Base.Vector Numeric.Rounded.Hardware.Backend.C.CDouble
instance Numeric.Rounded.Hardware.Internal.Class.RoundedFractional_Vector Data.Vector.Unboxed.Base.Vector Numeric.Rounded.Hardware.Backend.C.CDouble
instance Numeric.Rounded.Hardware.Internal.Class.RoundedSqrt_Vector Data.Vector.Unboxed.Base.Vector Numeric.Rounded.Hardware.Backend.C.CDouble
instance Data.Vector.Generic.Mutable.Base.MVector Data.Vector.Unboxed.Base.MVector Numeric.Rounded.Hardware.Backend.C.CDouble
instance Data.Vector.Generic.Base.Vector Data.Vector.Unboxed.Base.Vector Numeric.Rounded.Hardware.Backend.C.CDouble
instance Data.Vector.Unboxed.Base.Unbox Numeric.Rounded.Hardware.Backend.C.CDouble
instance Control.DeepSeq.NFData Numeric.Rounded.Hardware.Backend.C.CFloat
instance Numeric.Rounded.Hardware.Internal.Class.RoundedRing Numeric.Rounded.Hardware.Backend.C.CFloat
instance Numeric.Rounded.Hardware.Internal.Class.RoundedFractional Numeric.Rounded.Hardware.Backend.C.CFloat
instance Numeric.Rounded.Hardware.Internal.Class.RoundedSqrt Numeric.Rounded.Hardware.Backend.C.CFloat
instance Numeric.Rounded.Hardware.Internal.Class.RoundedRing_Vector Data.Vector.Storable.Vector Numeric.Rounded.Hardware.Backend.C.CFloat
instance Numeric.Rounded.Hardware.Internal.Class.RoundedFractional_Vector Data.Vector.Storable.Vector Numeric.Rounded.Hardware.Backend.C.CFloat
instance Numeric.Rounded.Hardware.Internal.Class.RoundedSqrt_Vector Data.Vector.Storable.Vector Numeric.Rounded.Hardware.Backend.C.CFloat
instance Numeric.Rounded.Hardware.Internal.Class.RoundedRing_Vector Data.Vector.Unboxed.Base.Vector Numeric.Rounded.Hardware.Backend.C.CFloat
instance Numeric.Rounded.Hardware.Internal.Class.RoundedFractional_Vector Data.Vector.Unboxed.Base.Vector Numeric.Rounded.Hardware.Backend.C.CFloat
instance Numeric.Rounded.Hardware.Internal.Class.RoundedSqrt_Vector Data.Vector.Unboxed.Base.Vector Numeric.Rounded.Hardware.Backend.C.CFloat
instance Data.Vector.Generic.Mutable.Base.MVector Data.Vector.Unboxed.Base.MVector Numeric.Rounded.Hardware.Backend.C.CFloat
instance Data.Vector.Generic.Base.Vector Data.Vector.Unboxed.Base.Vector Numeric.Rounded.Hardware.Backend.C.CFloat
instance Data.Vector.Unboxed.Base.Unbox Numeric.Rounded.Hardware.Backend.C.CFloat


-- | The types in this module implements interval addition and subtraction
--   in assembly.
--   
--   Currently, the only platform supported is x86_64.
--   
--   One of the following technology will be used to control rounding mode:
--   
--   <ul>
--   <li>SSE2 MXCSR</li>
--   <li>AVX512 EVEX encoding</li>
--   </ul>
--   
--   You should not need to import this module directly.
--   
--   This module may not be available depending on the platform or package
--   flags.
module Numeric.Rounded.Hardware.Backend.FastFFI
newtype CDouble
CDouble :: Double -> CDouble
fastIntervalAdd :: Double -> Double -> Double -> Double -> (Double, Double)
fastIntervalSub :: Double -> Double -> Double -> Double -> (Double, Double)
fastIntervalRecip :: Double -> Double -> (Double, Double)
data family MVector s a
data family Vector a
instance Foreign.Storable.Storable Numeric.Rounded.Hardware.Backend.FastFFI.CDouble
instance GHC.Num.Num Numeric.Rounded.Hardware.Backend.FastFFI.CDouble
instance GHC.Generics.Generic Numeric.Rounded.Hardware.Backend.FastFFI.CDouble
instance GHC.Show.Show Numeric.Rounded.Hardware.Backend.FastFFI.CDouble
instance GHC.Classes.Ord Numeric.Rounded.Hardware.Backend.FastFFI.CDouble
instance GHC.Classes.Eq Numeric.Rounded.Hardware.Backend.FastFFI.CDouble
instance Numeric.Rounded.Hardware.Internal.Class.RoundedRing_Vector Data.Vector.Unboxed.Base.Vector Numeric.Rounded.Hardware.Backend.FastFFI.CDouble
instance Numeric.Rounded.Hardware.Internal.Class.RoundedFractional_Vector Data.Vector.Unboxed.Base.Vector Numeric.Rounded.Hardware.Backend.FastFFI.CDouble
instance Numeric.Rounded.Hardware.Internal.Class.RoundedSqrt_Vector Data.Vector.Unboxed.Base.Vector Numeric.Rounded.Hardware.Backend.FastFFI.CDouble
instance Control.DeepSeq.NFData Numeric.Rounded.Hardware.Backend.FastFFI.CDouble
instance Numeric.Rounded.Hardware.Internal.Class.RoundedRing Numeric.Rounded.Hardware.Backend.FastFFI.CDouble
instance Numeric.Rounded.Hardware.Internal.Class.RoundedFractional Numeric.Rounded.Hardware.Backend.FastFFI.CDouble
instance Numeric.Rounded.Hardware.Internal.Class.RoundedSqrt Numeric.Rounded.Hardware.Backend.FastFFI.CDouble
instance Numeric.Rounded.Hardware.Internal.Class.RoundedRing_Vector Data.Vector.Storable.Vector Numeric.Rounded.Hardware.Backend.FastFFI.CDouble
instance Numeric.Rounded.Hardware.Internal.Class.RoundedFractional_Vector Data.Vector.Storable.Vector Numeric.Rounded.Hardware.Backend.FastFFI.CDouble
instance Numeric.Rounded.Hardware.Internal.Class.RoundedSqrt_Vector Data.Vector.Storable.Vector Numeric.Rounded.Hardware.Backend.FastFFI.CDouble
instance Data.Vector.Generic.Mutable.Base.MVector Data.Vector.Unboxed.Base.MVector Numeric.Rounded.Hardware.Backend.FastFFI.CDouble
instance Data.Vector.Generic.Base.Vector Data.Vector.Unboxed.Base.Vector Numeric.Rounded.Hardware.Backend.FastFFI.CDouble
instance Data.Vector.Unboxed.Base.Unbox Numeric.Rounded.Hardware.Backend.FastFFI.CDouble

module Numeric.Rounded.Hardware.Internal

-- | <pre>
--   &gt;&gt;&gt; binaryFloatToDecimalDigitsRn ToNearest 3 (0.125 :: Double)
--   ([1,2,5],0)
--   
--   &gt;&gt;&gt; binaryFloatToDecimalDigitsRn ToNearest 3 (12.5 :: Double)
--   ([1,2,5],2)
--   </pre>
binaryFloatToDecimalDigitsRn :: forall a. RealFloat a => RoundingMode -> Int -> a -> ([Int], Int)

-- | <pre>
--   &gt;&gt;&gt; binaryFloatToFixedDecimalDigitsRn ToNearest 3 (0.125 :: Double)
--   [1,2,5]
--   
--   &gt;&gt;&gt; binaryFloatToFixedDecimalDigitsRn ToNearest 3 (12.5 :: Double)
--   [1,2,5,0,0]
--   </pre>
binaryFloatToFixedDecimalDigitsRn :: forall a. RealFloat a => RoundingMode -> Int -> a -> [Int]

-- | <pre>
--   &gt;&gt;&gt; binaryFloatToDecimalDigits (0.125 :: Double)
--   ([1,2,5],0)
--   
--   &gt;&gt;&gt; binaryFloatToDecimalDigits (12.5 :: Double)
--   ([1,2,5],2)
--   </pre>
binaryFloatToDecimalDigits :: RealFloat a => a -> ([Int], Int)

-- | <pre>
--   &gt;&gt;&gt; showEFloatRn ToNearest (Just 0) (0 :: Double) ""
--   "0e0"
--   
--   &gt;&gt;&gt; showEFloatRn ToNearest Nothing (0 :: Double) ""
--   "0.0e0"
--   
--   &gt;&gt;&gt; showEFloatRn ToNearest Nothing (0.5 :: Double) ""
--   "5.0e-1"
--   </pre>
showEFloatRn :: RealFloat a => RoundingMode -> Maybe Int -> a -> ShowS

-- | <pre>
--   &gt;&gt;&gt; showFFloatRn ToNearest (Just 0) (0 :: Double) ""
--   "0"
--   
--   &gt;&gt;&gt; showFFloatRn ToNearest Nothing (0 :: Double) ""
--   "0.0"
--   
--   &gt;&gt;&gt; showFFloatRn ToNearest Nothing (-0 :: Double) ""
--   "-0.0"
--   
--   &gt;&gt;&gt; showFFloatRn ToNearest Nothing (-0.5 :: Double) ""
--   "-0.5"
--   </pre>
showFFloatRn :: RealFloat a => RoundingMode -> Maybe Int -> a -> ShowS
showGFloatRn :: RealFloat a => RoundingMode -> Maybe Int -> a -> ShowS

-- | The type for IEEE754 rounding-direction attributes.
data RoundingMode

-- | Round to the nearest value (IEEE754 roundTiesToEven)
ToNearest :: RoundingMode

-- | Round downward (IEEE754 roundTowardNegative)
TowardNegInf :: RoundingMode

-- | Round upward (IEEE754 roundTowardPositive)
TowardInf :: RoundingMode

-- | Round toward zero (IEEE754 roundTowardZero)
TowardZero :: RoundingMode

-- | Returns the opposite rounding direction.
--   
--   <tt>TowardNegInf</tt> and <tt>TowardInf</tt> are swapped.
oppositeRoundingMode :: RoundingMode -> RoundingMode

-- | This class allows you to recover the runtime value from a type-level
--   rounding mode.
--   
--   See <a>rounding</a>.
class Rounding (r :: RoundingMode)

-- | Recovers the value from type-level rounding mode.
rounding :: Rounding r => proxy r -> RoundingMode

-- | Lifts a rounding mode to type-level.
reifyRounding :: RoundingMode -> (forall s. Rounding s => Proxy s -> a) -> a

-- | A type tagged with a rounding direction.
--   
--   The rounding direction is effective for a <i>single</i> operation. You
--   won't get the correctly-rounded result for a compound expression like
--   <tt>(a - b * c) :: Rounded 'TowardInf Double</tt>.
--   
--   In particular, a negative literal like <tt>-0.1 :: Rounded r
--   Double</tt> doesn't yield the correctly-rounded value for
--   <tt>-0.1</tt>. To get the correct value, call <a>fromRational</a>
--   explicitly (i.e. <tt>fromRational (-0.1) :: Rounded r Double</tt>) or
--   use <tt>NegativeLiterals</tt> extension.
newtype Rounded (r :: RoundingMode) a
Rounded :: a -> Rounded (r :: RoundingMode) a
[getRounded] :: Rounded (r :: RoundingMode) a -> a
data family MVector s a
data family Vector a

-- | IEEE 754 <tt>nextUp</tt> operation.
--   
--   <pre>
--   &gt;&gt;&gt; nextUp 1 == (0x1.000002p0 :: Float)
--   True
--   
--   &gt;&gt;&gt; nextUp 1 == (0x1.0000_0000_0000_1p0 :: Double)
--   True
--   
--   &gt;&gt;&gt; nextUp (1/0) == (1/0 :: Double)
--   True
--   
--   &gt;&gt;&gt; nextUp (-1/0) == (- maxFinite :: Double)
--   True
--   
--   &gt;&gt;&gt; nextUp 0 == (0x1p-1074 :: Double)
--   True
--   
--   &gt;&gt;&gt; nextUp (-0) == (0x1p-1074 :: Double)
--   True
--   
--   &gt;&gt;&gt; nextUp (-0x1p-1074) :: Double -- should be negative zero
--   -0.0
--   </pre>
nextUp :: RealFloat a => a -> a

-- | IEEE 754 <tt>nextDown</tt> operation.
--   
--   <pre>
--   &gt;&gt;&gt; nextDown 1 == (0x1.ffff_ffff_ffff_fp-1 :: Double)
--   True
--   
--   &gt;&gt;&gt; nextDown 1 == (0x1.fffffep-1 :: Float)
--   True
--   
--   &gt;&gt;&gt; nextDown (1/0) == (maxFinite :: Double)
--   True
--   
--   &gt;&gt;&gt; nextDown (-1/0) == (-1/0 :: Double)
--   True
--   
--   &gt;&gt;&gt; nextDown 0 == (-0x1p-1074 :: Double)
--   True
--   
--   &gt;&gt;&gt; nextDown (-0) == (-0x1p-1074 :: Double)
--   True
--   
--   &gt;&gt;&gt; nextDown 0x1p-1074 -- should be positive zero
--   0.0
--   
--   &gt;&gt;&gt; nextDown 0x1p-1022 == (0x0.ffff_ffff_ffff_fp-1022 ::Double)
--   True
--   </pre>
nextDown :: RealFloat a => a -> a

-- | <pre>
--   &gt;&gt;&gt; nextTowardZero 1 == (0x1.ffff_ffff_ffff_fp-1 :: Double)
--   True
--   
--   &gt;&gt;&gt; nextTowardZero 1 == (0x1.fffffep-1 :: Float)
--   True
--   
--   &gt;&gt;&gt; nextTowardZero (1/0) == (maxFinite :: Double)
--   True
--   
--   &gt;&gt;&gt; nextTowardZero (-1/0) == (-maxFinite :: Double)
--   True
--   
--   &gt;&gt;&gt; nextTowardZero 0 :: Double -- should be positive zero
--   0.0
--   
--   &gt;&gt;&gt; nextTowardZero (-0 :: Double) -- should be negative zero
--   -0.0
--   
--   &gt;&gt;&gt; nextTowardZero 0x1p-1074 :: Double
--   0.0
--   </pre>
nextTowardZero :: RealFloat a => a -> a
distanceUlp :: RealFloat a => a -> a -> Maybe Integer

-- | IEEE 754 <tt>fusedMultiplyAdd</tt> operation.
--   
--   May make use of hardware FMA instructions if the target architecture
--   has it; set <tt>fma3</tt> package flag on x86 systems.
--   
--   <pre>
--   \(a :: Double) (b :: Double) (c :: Double) -&gt; fusedMultiplyAdd a b c == fromRational (toRational a * toRational b + toRational c)
--   </pre>
fusedMultiplyAdd :: RealFloat a => a -> a -> a -> a
roundedFromInteger_default :: RealFloat a => RoundingMode -> Integer -> a
roundedFromRational_default :: RealFloat a => RoundingMode -> Rational -> a
intervalFromInteger_default :: RealFloat a => Integer -> (Rounded 'TowardNegInf a, Rounded 'TowardInf a)
intervalFromIntegral :: (Integral i, RealFloat a) => i -> (Rounded 'TowardNegInf a, Rounded 'TowardInf a)
intervalFromRational_default :: RealFloat a => Rational -> (Rounded 'TowardNegInf a, Rounded 'TowardInf a)
class RealFloatConstants a

-- | &lt;math&gt;
positiveInfinity :: RealFloatConstants a => a

-- | &lt;math&gt;
negativeInfinity :: RealFloatConstants a => a
maxFinite :: RealFloatConstants a => a
minPositive :: RealFloatConstants a => a

-- | The correctly-rounded value of &lt;math&gt;
pi_down :: RealFloatConstants a => Rounded 'TowardNegInf a

-- | The correctly-rounded value of &lt;math&gt;
pi_up :: RealFloatConstants a => Rounded 'TowardInf a

-- | The correctly-rounded value of &lt;math&gt;
three_pi_down :: RealFloatConstants a => Rounded 'TowardNegInf a

-- | The correctly-rounded value of &lt;math&gt;
three_pi_up :: RealFloatConstants a => Rounded 'TowardInf a

-- | The correctly-rounded value of &lt;math&gt;
five_pi_down :: RealFloatConstants a => Rounded 'TowardNegInf a

-- | The correctly-rounded value of &lt;math&gt;
five_pi_up :: RealFloatConstants a => Rounded 'TowardInf a

-- | The correctly-rounded value of &lt;math&gt;
log2_down :: RealFloatConstants a => Rounded 'TowardNegInf a

-- | The correctly-rounded value of &lt;math&gt;
log2_up :: RealFloatConstants a => Rounded 'TowardInf a

-- | The correctly-rounded value of &lt;math&gt;
exp1_down :: RealFloatConstants a => Rounded 'TowardNegInf a

-- | The correctly-rounded value of &lt;math&gt;
exp1_up :: RealFloatConstants a => Rounded 'TowardInf a

-- | The correctly-rounded value of &lt;math&gt;
exp1_2_down :: RealFloatConstants a => Rounded 'TowardNegInf a

-- | The correctly-rounded value of &lt;math&gt;
exp1_2_up :: RealFloatConstants a => Rounded 'TowardInf a

-- | The correctly-rounded value of &lt;math&gt;
expm1_2_down :: RealFloatConstants a => Rounded 'TowardNegInf a

-- | The correctly-rounded value of &lt;math&gt;
expm1_2_up :: RealFloatConstants a => Rounded 'TowardInf a

-- | The correctly-rounded value of &lt;math&gt;
sqrt2_down :: RealFloatConstants a => Rounded 'TowardNegInf a

-- | The correctly-rounded value of &lt;math&gt;
sqrt2_up :: RealFloatConstants a => Rounded 'TowardInf a

-- | The correctly-rounded value of &lt;math&gt;
sqrt2m1_down :: RealFloatConstants a => Rounded 'TowardNegInf a

-- | The correctly-rounded value of &lt;math&gt;
sqrt2m1_up :: RealFloatConstants a => Rounded 'TowardInf a

-- | The correctly-rounded value of &lt;math&gt;
sqrt1_2_down :: RealFloatConstants a => Rounded 'TowardNegInf a

-- | The correctly-rounded value of &lt;math&gt;
sqrt1_2_up :: RealFloatConstants a => Rounded 'TowardInf a

-- | The correctly-rounded value of &lt;math&gt;
three_minus_2sqrt2_down :: RealFloatConstants a => Rounded 'TowardNegInf a

-- | The correctly-rounded value of &lt;math&gt;
three_minus_2sqrt2_up :: RealFloatConstants a => Rounded 'TowardInf a

-- | The correctly-rounded value of &lt;math&gt;
two_minus_sqrt2_down :: RealFloatConstants a => Rounded 'TowardNegInf a

-- | The correctly-rounded value of &lt;math&gt;
two_minus_sqrt2_up :: RealFloatConstants a => Rounded 'TowardInf a

-- | Lifted version of <a>RoundedSqrt</a>
class (RoundedSqrt a, RoundedRing_Vector vector a) => RoundedSqrt_Vector vector a

-- | Equivalent to <tt>map . <a>roundedSqrt</a></tt>
map_roundedSqrt :: RoundedSqrt_Vector vector a => RoundingMode -> vector a -> vector a

-- | Equivalent to <tt>map . <a>roundedSqrt</a></tt>
map_roundedSqrt :: (RoundedSqrt_Vector vector a, Vector vector a) => RoundingMode -> vector a -> vector a

-- | Lifted version of <a>RoundedFractional</a>
class (RoundedFractional a, RoundedRing_Vector vector a) => RoundedFractional_Vector vector a

-- | Equivalent to <tt>zipWith . <a>roundedDiv</a></tt>
zipWith_roundedDiv :: RoundedFractional_Vector vector a => RoundingMode -> vector a -> vector a -> vector a

-- | Equivalent to <tt>zipWith . <a>roundedDiv</a></tt>
zipWith_roundedDiv :: (RoundedFractional_Vector vector a, Vector vector a) => RoundingMode -> vector a -> vector a -> vector a

-- | Lifted version of <a>RoundedRing</a>
class RoundedRing a => RoundedRing_Vector vector a

-- | Equivalent to <tt>\r -&gt; foldl (<a>roundedAdd</a> r) 0</tt>
roundedSum :: RoundedRing_Vector vector a => RoundingMode -> vector a -> a

-- | Equivalent to <tt>zipWith . <a>roundedAdd</a></tt>
zipWith_roundedAdd :: RoundedRing_Vector vector a => RoundingMode -> vector a -> vector a -> vector a

-- | Equivalent to <tt>zipWith . <a>roundedSub</a></tt>
zipWith_roundedSub :: RoundedRing_Vector vector a => RoundingMode -> vector a -> vector a -> vector a

-- | Equivalent to <tt>zipWith . <a>roundedMul</a></tt>
zipWith_roundedMul :: RoundedRing_Vector vector a => RoundingMode -> vector a -> vector a -> vector a

-- | Equivalent to <tt>zipWith3 . <a>roundedFusedMultiplyAdd</a></tt>
zipWith3_roundedFusedMultiplyAdd :: RoundedRing_Vector vector a => RoundingMode -> vector a -> vector a -> vector a -> vector a

-- | Equivalent to <tt>\r -&gt; foldl (<a>roundedAdd</a> r) 0</tt>
roundedSum :: (RoundedRing_Vector vector a, Vector vector a, Num a) => RoundingMode -> vector a -> a

-- | Equivalent to <tt>zipWith . <a>roundedAdd</a></tt>
zipWith_roundedAdd :: (RoundedRing_Vector vector a, Vector vector a) => RoundingMode -> vector a -> vector a -> vector a

-- | Equivalent to <tt>zipWith . <a>roundedSub</a></tt>
zipWith_roundedSub :: (RoundedRing_Vector vector a, Vector vector a) => RoundingMode -> vector a -> vector a -> vector a

-- | Equivalent to <tt>zipWith . <a>roundedMul</a></tt>
zipWith_roundedMul :: (RoundedRing_Vector vector a, Vector vector a) => RoundingMode -> vector a -> vector a -> vector a

-- | Equivalent to <tt>zipWith3 . <a>roundedFusedMultiplyAdd</a></tt>
zipWith3_roundedFusedMultiplyAdd :: (RoundedRing_Vector vector a, Vector vector a) => RoundingMode -> vector a -> vector a -> vector a -> vector a

-- | Rounding-controlled version of <a>sqrt</a>.
class RoundedRing a => RoundedSqrt a
roundedSqrt :: RoundedSqrt a => RoundingMode -> a -> a
intervalSqrt :: RoundedSqrt a => Rounded 'TowardNegInf a -> Rounded 'TowardInf a -> (Rounded 'TowardNegInf a, Rounded 'TowardInf a)

-- | Rounding-controlled version of <a>Fractional</a>.
class RoundedRing a => RoundedFractional a
roundedDiv :: RoundedFractional a => RoundingMode -> a -> a -> a
roundedRecip :: RoundedFractional a => RoundingMode -> a -> a
roundedRecip :: (RoundedFractional a, Num a) => RoundingMode -> a -> a
roundedFromRational :: RoundedFractional a => RoundingMode -> Rational -> a
roundedFromRational :: (RoundedFractional a, RealFloat a) => RoundingMode -> Rational -> a
roundedFromRealFloat :: (RoundedFractional a, RealFloat b) => RoundingMode -> b -> a
roundedFromRealFloat :: (RoundedFractional a, Fractional a, RealFloat b) => RoundingMode -> b -> a
intervalDiv :: RoundedFractional a => Rounded 'TowardNegInf a -> Rounded 'TowardInf a -> Rounded 'TowardNegInf a -> Rounded 'TowardInf a -> (Rounded 'TowardNegInf a, Rounded 'TowardInf a)
intervalDivAdd :: RoundedFractional a => Rounded 'TowardNegInf a -> Rounded 'TowardInf a -> Rounded 'TowardNegInf a -> Rounded 'TowardInf a -> Rounded 'TowardNegInf a -> Rounded 'TowardInf a -> (Rounded 'TowardNegInf a, Rounded 'TowardInf a)
intervalRecip :: RoundedFractional a => Rounded 'TowardNegInf a -> Rounded 'TowardInf a -> (Rounded 'TowardNegInf a, Rounded 'TowardInf a)
intervalFromRational :: RoundedFractional a => Rational -> (Rounded 'TowardNegInf a, Rounded 'TowardInf a)

-- | Rounding-controlled version of <a>Num</a>.
class Ord a => RoundedRing a
roundedAdd :: RoundedRing a => RoundingMode -> a -> a -> a
roundedSub :: RoundedRing a => RoundingMode -> a -> a -> a
roundedMul :: RoundedRing a => RoundingMode -> a -> a -> a
roundedFusedMultiplyAdd :: RoundedRing a => RoundingMode -> a -> a -> a -> a
roundedFromInteger :: RoundedRing a => RoundingMode -> Integer -> a
roundedFromInteger :: (RoundedRing a, RealFloat a) => RoundingMode -> Integer -> a

-- | <pre>
--   \x_lo x_hi y_lo y_hi -&gt; intervalAdd (Rounded x_lo) (Rounded x_hi) (Rounded y_lo) (Rounded y_hi) == (Rounded (roundedAdd TowardNegInf x_lo y_lo), Rounded (roundedAdd TowardInf x_hi y_hi))
--   </pre>
intervalAdd :: RoundedRing a => Rounded 'TowardNegInf a -> Rounded 'TowardInf a -> Rounded 'TowardNegInf a -> Rounded 'TowardInf a -> (Rounded 'TowardNegInf a, Rounded 'TowardInf a)

-- | <pre>
--   \x_lo x_hi y_lo y_hi -&gt; intervalSub (Rounded x_lo) (Rounded x_hi) (Rounded y_lo) (Rounded y_hi) == (Rounded (roundedSub TowardNegInf x_lo y_hi), Rounded (roundedSub TowardInf x_hi y_lo))
--   </pre>
intervalSub :: RoundedRing a => Rounded 'TowardNegInf a -> Rounded 'TowardInf a -> Rounded 'TowardNegInf a -> Rounded 'TowardInf a -> (Rounded 'TowardNegInf a, Rounded 'TowardInf a)
intervalMul :: RoundedRing a => Rounded 'TowardNegInf a -> Rounded 'TowardInf a -> Rounded 'TowardNegInf a -> Rounded 'TowardInf a -> (Rounded 'TowardNegInf a, Rounded 'TowardInf a)
intervalMulAdd :: RoundedRing a => Rounded 'TowardNegInf a -> Rounded 'TowardInf a -> Rounded 'TowardNegInf a -> Rounded 'TowardInf a -> Rounded 'TowardNegInf a -> Rounded 'TowardInf a -> (Rounded 'TowardNegInf a, Rounded 'TowardInf a)
intervalFromInteger :: RoundedRing a => Integer -> (Rounded 'TowardNegInf a, Rounded 'TowardInf a)
backendNameT :: RoundedRing a => Tagged a String

-- | Returns the name of backend as a string.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; :m + Data.Proxy
--   &gt;&gt;&gt; <a>backendName</a> (Proxy :: Proxy Double)
--   "FastFFI+SSE2"
--   </pre>
backendName :: RoundedRing a => proxy a -> String

-- | The type for IEEE754 rounding-direction attributes.
data RoundingMode

-- | Round to the nearest value (IEEE754 roundTiesToEven)
ToNearest :: RoundingMode

-- | Round downward (IEEE754 roundTowardNegative)
TowardNegInf :: RoundingMode

-- | Round upward (IEEE754 roundTowardPositive)
TowardInf :: RoundingMode

-- | Round toward zero (IEEE754 roundTowardZero)
TowardZero :: RoundingMode

-- | Returns the opposite rounding direction.
--   
--   <tt>TowardNegInf</tt> and <tt>TowardInf</tt> are swapped.
oppositeRoundingMode :: RoundingMode -> RoundingMode

-- | This class allows you to recover the runtime value from a type-level
--   rounding mode.
--   
--   See <a>rounding</a>.
class Rounding (r :: RoundingMode)

-- | Recovers the value from type-level rounding mode.
rounding :: Rounding r => proxy r -> RoundingMode

-- | Lifts a rounding mode to type-level.
reifyRounding :: RoundingMode -> (forall s. Rounding s => Proxy s -> a) -> a

-- | A type tagged with a rounding direction.
--   
--   The rounding direction is effective for a <i>single</i> operation. You
--   won't get the correctly-rounded result for a compound expression like
--   <tt>(a - b * c) :: Rounded 'TowardInf Double</tt>.
--   
--   In particular, a negative literal like <tt>-0.1 :: Rounded r
--   Double</tt> doesn't yield the correctly-rounded value for
--   <tt>-0.1</tt>. To get the correct value, call <a>fromRational</a>
--   explicitly (i.e. <tt>fromRational (-0.1) :: Rounded r Double</tt>) or
--   use <tt>NegativeLiterals</tt> extension.
newtype Rounded (r :: RoundingMode) a
Rounded :: a -> Rounded (r :: RoundingMode) a
[getRounded] :: Rounded (r :: RoundingMode) a -> a
data family MVector s a
data family Vector a

module Numeric.Rounded.Hardware.Class

-- | Rounding-controlled version of <a>Num</a>.
class Ord a => RoundedRing a
roundedAdd :: RoundedRing a => RoundingMode -> a -> a -> a
roundedSub :: RoundedRing a => RoundingMode -> a -> a -> a
roundedMul :: RoundedRing a => RoundingMode -> a -> a -> a
roundedFusedMultiplyAdd :: RoundedRing a => RoundingMode -> a -> a -> a -> a
roundedFromInteger :: RoundedRing a => RoundingMode -> Integer -> a
roundedFromInteger :: (RoundedRing a, RealFloat a) => RoundingMode -> Integer -> a

-- | <pre>
--   \x_lo x_hi y_lo y_hi -&gt; intervalAdd (Rounded x_lo) (Rounded x_hi) (Rounded y_lo) (Rounded y_hi) == (Rounded (roundedAdd TowardNegInf x_lo y_lo), Rounded (roundedAdd TowardInf x_hi y_hi))
--   </pre>
intervalAdd :: RoundedRing a => Rounded 'TowardNegInf a -> Rounded 'TowardInf a -> Rounded 'TowardNegInf a -> Rounded 'TowardInf a -> (Rounded 'TowardNegInf a, Rounded 'TowardInf a)

-- | <pre>
--   \x_lo x_hi y_lo y_hi -&gt; intervalSub (Rounded x_lo) (Rounded x_hi) (Rounded y_lo) (Rounded y_hi) == (Rounded (roundedSub TowardNegInf x_lo y_hi), Rounded (roundedSub TowardInf x_hi y_lo))
--   </pre>
intervalSub :: RoundedRing a => Rounded 'TowardNegInf a -> Rounded 'TowardInf a -> Rounded 'TowardNegInf a -> Rounded 'TowardInf a -> (Rounded 'TowardNegInf a, Rounded 'TowardInf a)
intervalMul :: RoundedRing a => Rounded 'TowardNegInf a -> Rounded 'TowardInf a -> Rounded 'TowardNegInf a -> Rounded 'TowardInf a -> (Rounded 'TowardNegInf a, Rounded 'TowardInf a)
intervalMulAdd :: RoundedRing a => Rounded 'TowardNegInf a -> Rounded 'TowardInf a -> Rounded 'TowardNegInf a -> Rounded 'TowardInf a -> Rounded 'TowardNegInf a -> Rounded 'TowardInf a -> (Rounded 'TowardNegInf a, Rounded 'TowardInf a)
intervalFromInteger :: RoundedRing a => Integer -> (Rounded 'TowardNegInf a, Rounded 'TowardInf a)
backendNameT :: RoundedRing a => Tagged a String

-- | Rounding-controlled version of <a>Fractional</a>.
class RoundedRing a => RoundedFractional a
roundedDiv :: RoundedFractional a => RoundingMode -> a -> a -> a
roundedRecip :: RoundedFractional a => RoundingMode -> a -> a
roundedRecip :: (RoundedFractional a, Num a) => RoundingMode -> a -> a
roundedFromRational :: RoundedFractional a => RoundingMode -> Rational -> a
roundedFromRational :: (RoundedFractional a, RealFloat a) => RoundingMode -> Rational -> a
roundedFromRealFloat :: (RoundedFractional a, RealFloat b) => RoundingMode -> b -> a
roundedFromRealFloat :: (RoundedFractional a, Fractional a, RealFloat b) => RoundingMode -> b -> a
intervalDiv :: RoundedFractional a => Rounded 'TowardNegInf a -> Rounded 'TowardInf a -> Rounded 'TowardNegInf a -> Rounded 'TowardInf a -> (Rounded 'TowardNegInf a, Rounded 'TowardInf a)
intervalDivAdd :: RoundedFractional a => Rounded 'TowardNegInf a -> Rounded 'TowardInf a -> Rounded 'TowardNegInf a -> Rounded 'TowardInf a -> Rounded 'TowardNegInf a -> Rounded 'TowardInf a -> (Rounded 'TowardNegInf a, Rounded 'TowardInf a)
intervalRecip :: RoundedFractional a => Rounded 'TowardNegInf a -> Rounded 'TowardInf a -> (Rounded 'TowardNegInf a, Rounded 'TowardInf a)
intervalFromRational :: RoundedFractional a => Rational -> (Rounded 'TowardNegInf a, Rounded 'TowardInf a)

-- | Rounding-controlled version of <a>sqrt</a>.
class RoundedRing a => RoundedSqrt a
roundedSqrt :: RoundedSqrt a => RoundingMode -> a -> a
intervalSqrt :: RoundedSqrt a => Rounded 'TowardNegInf a -> Rounded 'TowardInf a -> (Rounded 'TowardNegInf a, Rounded 'TowardInf a)

-- | Lifted version of <a>RoundedRing</a>
class RoundedRing a => RoundedRing_Vector vector a

-- | Equivalent to <tt>\r -&gt; foldl (<a>roundedAdd</a> r) 0</tt>
roundedSum :: RoundedRing_Vector vector a => RoundingMode -> vector a -> a

-- | Equivalent to <tt>zipWith . <a>roundedAdd</a></tt>
zipWith_roundedAdd :: RoundedRing_Vector vector a => RoundingMode -> vector a -> vector a -> vector a

-- | Equivalent to <tt>zipWith . <a>roundedSub</a></tt>
zipWith_roundedSub :: RoundedRing_Vector vector a => RoundingMode -> vector a -> vector a -> vector a

-- | Equivalent to <tt>zipWith . <a>roundedMul</a></tt>
zipWith_roundedMul :: RoundedRing_Vector vector a => RoundingMode -> vector a -> vector a -> vector a

-- | Equivalent to <tt>zipWith3 . <a>roundedFusedMultiplyAdd</a></tt>
zipWith3_roundedFusedMultiplyAdd :: RoundedRing_Vector vector a => RoundingMode -> vector a -> vector a -> vector a -> vector a

-- | Equivalent to <tt>\r -&gt; foldl (<a>roundedAdd</a> r) 0</tt>
roundedSum :: (RoundedRing_Vector vector a, Vector vector a, Num a) => RoundingMode -> vector a -> a

-- | Equivalent to <tt>zipWith . <a>roundedAdd</a></tt>
zipWith_roundedAdd :: (RoundedRing_Vector vector a, Vector vector a) => RoundingMode -> vector a -> vector a -> vector a

-- | Equivalent to <tt>zipWith . <a>roundedSub</a></tt>
zipWith_roundedSub :: (RoundedRing_Vector vector a, Vector vector a) => RoundingMode -> vector a -> vector a -> vector a

-- | Equivalent to <tt>zipWith . <a>roundedMul</a></tt>
zipWith_roundedMul :: (RoundedRing_Vector vector a, Vector vector a) => RoundingMode -> vector a -> vector a -> vector a

-- | Equivalent to <tt>zipWith3 . <a>roundedFusedMultiplyAdd</a></tt>
zipWith3_roundedFusedMultiplyAdd :: (RoundedRing_Vector vector a, Vector vector a) => RoundingMode -> vector a -> vector a -> vector a -> vector a

-- | Lifted version of <a>RoundedFractional</a>
class (RoundedFractional a, RoundedRing_Vector vector a) => RoundedFractional_Vector vector a

-- | Equivalent to <tt>zipWith . <a>roundedDiv</a></tt>
zipWith_roundedDiv :: RoundedFractional_Vector vector a => RoundingMode -> vector a -> vector a -> vector a

-- | Equivalent to <tt>zipWith . <a>roundedDiv</a></tt>
zipWith_roundedDiv :: (RoundedFractional_Vector vector a, Vector vector a) => RoundingMode -> vector a -> vector a -> vector a

-- | Lifted version of <a>RoundedSqrt</a>
class (RoundedSqrt a, RoundedRing_Vector vector a) => RoundedSqrt_Vector vector a

-- | Equivalent to <tt>map . <a>roundedSqrt</a></tt>
map_roundedSqrt :: RoundedSqrt_Vector vector a => RoundingMode -> vector a -> vector a

-- | Equivalent to <tt>map . <a>roundedSqrt</a></tt>
map_roundedSqrt :: (RoundedSqrt_Vector vector a, Vector vector a) => RoundingMode -> vector a -> vector a


-- | Although popular CPUs allow program to control the rounding direction
--   of floating-point operations, such feature is not directly accessible
--   to Haskell.
--   
--   Several options are available to control the rounding direction,
--   including
--   
--   <ul>
--   <li>Emulate the operations using <a>Rational</a>.</li>
--   <li>Emulate the desired rounding behavior using the default rounding
--   direction (i.e. round to nearest).</li>
--   <li>Provide the rounding-direction-controlled operations in C or
--   assembly, and use FFI to call them from Haskell.<ul><li>C FFI is
--   portable, but has limitations (e.g. cannot return multiple values
--   directly).</li><li>GHC-specific <tt>foreign import prim</tt> can
--   return multiple values efficiently, but cannot be implemented in
--   C.</li></ul></li>
--   </ul>
--   
--   This library implements the first and third options, in
--   <a>Numeric.Rounded.Hardware.Backend.ViaRational</a> and
--   <a>Numeric.Rounded.Hardware.Backend.C</a>/<a>Numeric.Rounded.Hardware.Backend.FastFFI</a>
--   respectively.
--   
--   The default implementation for <a>Float</a> and <a>Double</a> depends
--   on the platform and package flags. To help the programmer identify
--   which implementation is used, this module provides a function to
--   obtain the name of implementation.
--   
--   To disable use of FFI, enable the package flag <tt>pure-hs</tt>.
module Numeric.Rounded.Hardware.Backend

-- | Returns the name of backend as a string.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; :m + Data.Proxy
--   &gt;&gt;&gt; <a>backendName</a> (Proxy :: Proxy Double)
--   "FastFFI+SSE2"
--   </pre>
backendName :: RoundedRing a => proxy a -> String

module Numeric.Rounded.Hardware

-- | A type tagged with a rounding direction.
--   
--   The rounding direction is effective for a <i>single</i> operation. You
--   won't get the correctly-rounded result for a compound expression like
--   <tt>(a - b * c) :: Rounded 'TowardInf Double</tt>.
--   
--   In particular, a negative literal like <tt>-0.1 :: Rounded r
--   Double</tt> doesn't yield the correctly-rounded value for
--   <tt>-0.1</tt>. To get the correct value, call <a>fromRational</a>
--   explicitly (i.e. <tt>fromRational (-0.1) :: Rounded r Double</tt>) or
--   use <tt>NegativeLiterals</tt> extension.
newtype Rounded (r :: RoundingMode) a
Rounded :: a -> Rounded (r :: RoundingMode) a
[getRounded] :: Rounded (r :: RoundingMode) a -> a

-- | The type for IEEE754 rounding-direction attributes.
data RoundingMode

-- | Round to the nearest value (IEEE754 roundTiesToEven)
ToNearest :: RoundingMode

-- | Round downward (IEEE754 roundTowardNegative)
TowardNegInf :: RoundingMode

-- | Round upward (IEEE754 roundTowardPositive)
TowardInf :: RoundingMode

-- | Round toward zero (IEEE754 roundTowardZero)
TowardZero :: RoundingMode

-- | This class allows you to recover the runtime value from a type-level
--   rounding mode.
--   
--   See <a>rounding</a>.
class Rounding (r :: RoundingMode)

-- | Rounding-controlled version of <a>Num</a>.
class Ord a => RoundedRing a

-- | Rounding-controlled version of <a>Fractional</a>.
class RoundedRing a => RoundedFractional a

-- | Rounding-controlled version of <a>sqrt</a>.
class RoundedRing a => RoundedSqrt a

module Numeric.Rounded.Hardware.Interval.Class
class IsInterval i where {
    type family EndPoint i;
}
withEndPoints :: IsInterval i => (Rounded 'TowardNegInf (EndPoint i) -> Rounded 'TowardInf (EndPoint i) -> i) -> i -> i
singleton :: IsInterval i => EndPoint i -> i
makeInterval :: IsInterval i => Rounded 'TowardNegInf (EndPoint i) -> Rounded 'TowardInf (EndPoint i) -> i
width :: IsInterval i => i -> Rounded 'TowardInf (EndPoint i)
hull :: IsInterval i => i -> i -> i
intersection :: IsInterval i => i -> i -> i
maybeIntersection :: IsInterval i => i -> i -> Maybe i
equalAsSet :: IsInterval i => i -> i -> Bool

-- | <tt>a</tt> is a subset of <tt>b</tt>
subset :: IsInterval i => i -> i -> Bool
weaklyLess :: IsInterval i => i -> i -> Bool
precedes :: IsInterval i => i -> i -> Bool
interior :: IsInterval i => i -> i -> Bool
strictLess :: IsInterval i => i -> i -> Bool
strictPrecedes :: IsInterval i => i -> i -> Bool
disjoint :: IsInterval i => i -> i -> Bool
infix 4 `disjoint`
infix 4 `strictPrecedes`
infix 4 `strictLess`
infix 4 `interior`
infix 4 `precedes`
infix 4 `weaklyLess`
infix 4 `subset`
infix 4 `equalAsSet`

module Numeric.Rounded.Hardware.Interval.NonEmpty
data Interval a
I :: !Rounded 'TowardNegInf a -> !Rounded 'TowardInf a -> Interval a
increasing :: (forall r. Rounding r => Rounded r a -> Rounded r a) -> Interval a -> Interval a
maxI :: Ord a => Interval a -> Interval a -> Interval a
minI :: Ord a => Interval a -> Interval a -> Interval a
powInt :: (Ord a, Num a, RoundedRing a) => Interval a -> Int -> Interval a
null :: Interval a -> Bool
inf :: Interval a -> Rounded 'TowardNegInf a
sup :: Interval a -> Rounded 'TowardInf a
width :: (Num a, RoundedRing a) => Interval a -> Rounded 'TowardInf a
hull :: RoundedRing a => Interval a -> Interval a -> Interval a
instance GHC.Generics.Generic (Numeric.Rounded.Hardware.Interval.NonEmpty.Interval a)
instance GHC.Show.Show a => GHC.Show.Show (Numeric.Rounded.Hardware.Interval.NonEmpty.Interval a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Numeric.Rounded.Hardware.Interval.NonEmpty.Interval a)
instance (GHC.Num.Num a, Numeric.Rounded.Hardware.Internal.Class.RoundedRing a) => GHC.Num.Num (Numeric.Rounded.Hardware.Interval.NonEmpty.Interval a)
instance (GHC.Num.Num a, Numeric.Rounded.Hardware.Internal.Class.RoundedFractional a) => GHC.Real.Fractional (Numeric.Rounded.Hardware.Interval.NonEmpty.Interval a)
instance (GHC.Num.Num a, Numeric.Rounded.Hardware.Internal.Class.RoundedFractional a, Numeric.Rounded.Hardware.Internal.Class.RoundedSqrt a, GHC.Classes.Eq a, GHC.Float.RealFloat a, Numeric.Rounded.Hardware.Internal.Constants.RealFloatConstants a) => GHC.Float.Floating (Numeric.Rounded.Hardware.Interval.NonEmpty.Interval a)
instance (GHC.Float.RealFloat a, Numeric.Rounded.Hardware.Internal.Class.RoundedRing a) => Numeric.Rounded.Hardware.Interval.Class.IsInterval (Numeric.Rounded.Hardware.Interval.NonEmpty.Interval a)
instance (Data.Vector.Unboxed.Base.Unbox a, GHC.Classes.Ord a, GHC.Real.Fractional a) => Data.Vector.Generic.Mutable.Base.MVector Data.Vector.Unboxed.Base.MVector (Numeric.Rounded.Hardware.Interval.NonEmpty.Interval a)
instance (Data.Vector.Unboxed.Base.Unbox a, GHC.Classes.Ord a, GHC.Real.Fractional a) => Data.Vector.Generic.Base.Vector Data.Vector.Unboxed.Base.Vector (Numeric.Rounded.Hardware.Interval.NonEmpty.Interval a)
instance (Data.Vector.Unboxed.Base.Unbox a, GHC.Classes.Ord a, GHC.Real.Fractional a) => Data.Vector.Unboxed.Base.Unbox (Numeric.Rounded.Hardware.Interval.NonEmpty.Interval a)
instance (Data.Primitive.Types.Prim a, GHC.Classes.Ord a, GHC.Real.Fractional a) => Data.Array.Base.MArray (Data.Array.Base.STUArray s) (Numeric.Rounded.Hardware.Interval.NonEmpty.Interval a) (GHC.ST.ST s)
instance (Data.Primitive.Types.Prim a, GHC.Classes.Ord a, GHC.Real.Fractional a) => Data.Array.Base.IArray Data.Array.Base.UArray (Numeric.Rounded.Hardware.Interval.NonEmpty.Interval a)

module Numeric.Rounded.Hardware.Interval
data Interval a
I :: !Rounded 'TowardNegInf a -> !Rounded 'TowardInf a -> Interval a
Empty :: Interval a
increasing :: (forall r. Rounding r => Rounded r a -> Rounded r a) -> Interval a -> Interval a
maxI :: Ord a => Interval a -> Interval a -> Interval a
minI :: Ord a => Interval a -> Interval a -> Interval a
powInt :: (Ord a, Num a, RoundedRing a) => Interval a -> Int -> Interval a
null :: Interval a -> Bool
inf :: Interval a -> Rounded 'TowardNegInf a
sup :: Interval a -> Rounded 'TowardInf a
width :: (Num a, RoundedRing a) => Interval a -> Rounded 'TowardInf a
widthUlp :: RealFloat a => Interval a -> Maybe Integer
hull :: RoundedRing a => Interval a -> Interval a -> Interval a
intersection :: RoundedRing a => Interval a -> Interval a -> Interval a
instance GHC.Generics.Generic (Numeric.Rounded.Hardware.Interval.Interval a)
instance GHC.Show.Show a => GHC.Show.Show (Numeric.Rounded.Hardware.Interval.Interval a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Numeric.Rounded.Hardware.Interval.Interval a)
instance (GHC.Num.Num a, Numeric.Rounded.Hardware.Internal.Class.RoundedRing a) => GHC.Num.Num (Numeric.Rounded.Hardware.Interval.Interval a)
instance (GHC.Num.Num a, Numeric.Rounded.Hardware.Internal.Class.RoundedFractional a) => GHC.Real.Fractional (Numeric.Rounded.Hardware.Interval.Interval a)
instance (GHC.Num.Num a, Numeric.Rounded.Hardware.Internal.Class.RoundedFractional a, Numeric.Rounded.Hardware.Internal.Class.RoundedSqrt a, GHC.Classes.Eq a, GHC.Float.RealFloat a, Numeric.Rounded.Hardware.Internal.Constants.RealFloatConstants a) => GHC.Float.Floating (Numeric.Rounded.Hardware.Interval.Interval a)
instance (GHC.Num.Num a, Numeric.Rounded.Hardware.Internal.Class.RoundedRing a, GHC.Float.RealFloat a) => Numeric.Rounded.Hardware.Interval.Class.IsInterval (Numeric.Rounded.Hardware.Interval.Interval a)
instance (Data.Vector.Unboxed.Base.Unbox a, GHC.Classes.Ord a, GHC.Real.Fractional a) => Data.Vector.Generic.Mutable.Base.MVector Data.Vector.Unboxed.Base.MVector (Numeric.Rounded.Hardware.Interval.Interval a)
instance (Data.Vector.Unboxed.Base.Unbox a, GHC.Classes.Ord a, GHC.Real.Fractional a) => Data.Vector.Generic.Base.Vector Data.Vector.Unboxed.Base.Vector (Numeric.Rounded.Hardware.Interval.Interval a)
instance (Data.Vector.Unboxed.Base.Unbox a, GHC.Classes.Ord a, GHC.Real.Fractional a) => Data.Vector.Unboxed.Base.Unbox (Numeric.Rounded.Hardware.Interval.Interval a)
instance (Data.Primitive.Types.Prim a, GHC.Classes.Ord a, GHC.Real.Fractional a) => Data.Array.Base.MArray (Data.Array.Base.STUArray s) (Numeric.Rounded.Hardware.Interval.Interval a) (GHC.ST.ST s)
instance (Data.Primitive.Types.Prim a, GHC.Classes.Ord a, GHC.Real.Fractional a) => Data.Array.Base.IArray Data.Array.Base.UArray (Numeric.Rounded.Hardware.Interval.Interval a)

module Numeric.Rounded.Hardware.Rounding

-- | The type for IEEE754 rounding-direction attributes.
data RoundingMode

-- | Round to the nearest value (IEEE754 roundTiesToEven)
ToNearest :: RoundingMode

-- | Round downward (IEEE754 roundTowardNegative)
TowardNegInf :: RoundingMode

-- | Round upward (IEEE754 roundTowardPositive)
TowardInf :: RoundingMode

-- | Round toward zero (IEEE754 roundTowardZero)
TowardZero :: RoundingMode

-- | Returns the opposite rounding direction.
--   
--   <tt>TowardNegInf</tt> and <tt>TowardInf</tt> are swapped.
oppositeRoundingMode :: RoundingMode -> RoundingMode

-- | This class allows you to recover the runtime value from a type-level
--   rounding mode.
--   
--   See <a>rounding</a>.
class Rounding (r :: RoundingMode)

-- | Recovers the value from type-level rounding mode.
rounding :: Rounding r => proxy r -> RoundingMode

-- | Lifts a rounding mode to type-level.
reifyRounding :: RoundingMode -> (forall s. Rounding s => Proxy s -> a) -> a

module Numeric.Rounded.Hardware.Vector.Storable
coercion :: Coercion (Vector a) (Vector (Rounded r a))
fromVectorOfRounded :: Vector (Rounded r a) -> Vector a
toVectorOfRounded :: Vector a -> Vector (Rounded r a)
coercionM :: Coercion (MVector s a) (MVector s (Rounded r a))
fromMVectorOfRounded :: MVector s (Rounded r a) -> MVector s a
toMVectorOfRounded :: MVector s a -> MVector s (Rounded r a)

-- | Equivalent to <tt>\r -&gt; foldl (<a>roundedAdd</a> r) 0</tt>
roundedSum :: RoundedRing_Vector vector a => RoundingMode -> vector a -> a

-- | Equivalent to <tt>zipWith . <a>roundedAdd</a></tt>
zipWith_roundedAdd :: RoundedRing_Vector vector a => RoundingMode -> vector a -> vector a -> vector a

-- | Equivalent to <tt>zipWith . <a>roundedSub</a></tt>
zipWith_roundedSub :: RoundedRing_Vector vector a => RoundingMode -> vector a -> vector a -> vector a

-- | Equivalent to <tt>zipWith . <a>roundedMul</a></tt>
zipWith_roundedMul :: RoundedRing_Vector vector a => RoundingMode -> vector a -> vector a -> vector a

-- | Equivalent to <tt>zipWith3 . <a>roundedFusedMultiplyAdd</a></tt>
zipWith3_roundedFusedMultiplyAdd :: RoundedRing_Vector vector a => RoundingMode -> vector a -> vector a -> vector a -> vector a

-- | Equivalent to <tt>zipWith . <a>roundedDiv</a></tt>
zipWith_roundedDiv :: RoundedFractional_Vector vector a => RoundingMode -> vector a -> vector a -> vector a

-- | Equivalent to <tt>map . <a>roundedSqrt</a></tt>
map_roundedSqrt :: RoundedSqrt_Vector vector a => RoundingMode -> vector a -> vector a

-- | Equivalent to <a>sum</a>
sum :: forall r a. (Rounding r, Storable a, RoundedRing_Vector Vector a) => Vector (Rounded r a) -> Rounded r a

-- | Equivalent to <tt><a>zipWith</a> (+)</tt>
zipWith_add :: forall r a. (Rounding r, Storable a, RoundedRing_Vector Vector a) => Vector (Rounded r a) -> Vector (Rounded r a) -> Vector (Rounded r a)

-- | Equivalent to <tt><a>zipWith</a> (-)</tt>
zipWith_sub :: forall r a. (Rounding r, Storable a, RoundedRing_Vector Vector a) => Vector (Rounded r a) -> Vector (Rounded r a) -> Vector (Rounded r a)

-- | Equivalent to <tt><a>zipWith</a> (*)</tt>
zipWith_mul :: forall r a. (Rounding r, Storable a, RoundedRing_Vector Vector a) => Vector (Rounded r a) -> Vector (Rounded r a) -> Vector (Rounded r a)

-- | Equivalent to <tt><a>zipWith3</a> fusedMultiplyAdd</tt>
zipWith3_fusedMultiplyAdd :: forall r a. (Rounding r, Storable a, RoundedRing_Vector Vector a) => Vector (Rounded r a) -> Vector (Rounded r a) -> Vector (Rounded r a) -> Vector (Rounded r a)

-- | Equivalent to <tt><a>zipWith</a> (/)</tt>
zipWith_div :: forall r a. (Rounding r, Storable a, RoundedFractional_Vector Vector a) => Vector (Rounded r a) -> Vector (Rounded r a) -> Vector (Rounded r a)

-- | Equivalent to <tt><a>map</a> sqrt</tt>
map_sqrt :: forall r a. (Rounding r, Storable a, RoundedSqrt_Vector Vector a) => Vector (Rounded r a) -> Vector (Rounded r a)

module Numeric.Rounded.Hardware.Vector.Unboxed

-- | Equivalent to <tt>\r -&gt; foldl (<a>roundedAdd</a> r) 0</tt>
roundedSum :: RoundedRing_Vector vector a => RoundingMode -> vector a -> a

-- | Equivalent to <tt>zipWith . <a>roundedAdd</a></tt>
zipWith_roundedAdd :: RoundedRing_Vector vector a => RoundingMode -> vector a -> vector a -> vector a

-- | Equivalent to <tt>zipWith . <a>roundedSub</a></tt>
zipWith_roundedSub :: RoundedRing_Vector vector a => RoundingMode -> vector a -> vector a -> vector a

-- | Equivalent to <tt>zipWith . <a>roundedMul</a></tt>
zipWith_roundedMul :: RoundedRing_Vector vector a => RoundingMode -> vector a -> vector a -> vector a

-- | Equivalent to <tt>zipWith3 . <a>roundedFusedMultiplyAdd</a></tt>
zipWith3_roundedFusedMultiplyAdd :: RoundedRing_Vector vector a => RoundingMode -> vector a -> vector a -> vector a -> vector a

-- | Equivalent to <tt>zipWith . <a>roundedDiv</a></tt>
zipWith_roundedDiv :: RoundedFractional_Vector vector a => RoundingMode -> vector a -> vector a -> vector a

-- | Equivalent to <tt>map . <a>roundedSqrt</a></tt>
map_roundedSqrt :: RoundedSqrt_Vector vector a => RoundingMode -> vector a -> vector a

-- | Equivalent to <a>sum</a>
sum :: forall r a. (Rounding r, Unbox a, RoundedRing_Vector Vector a) => Vector (Rounded r a) -> Rounded r a

-- | Equivalent to <tt><a>zipWith</a> (+)</tt>
zipWith_add :: forall r a. (Rounding r, Unbox a, RoundedRing_Vector Vector a) => Vector (Rounded r a) -> Vector (Rounded r a) -> Vector (Rounded r a)

-- | Equivalent to <tt><a>zipWith</a> (-)</tt>
zipWith_sub :: forall r a. (Rounding r, Unbox a, RoundedRing_Vector Vector a) => Vector (Rounded r a) -> Vector (Rounded r a) -> Vector (Rounded r a)

-- | Equivalent to <tt><a>zipWith</a> (*)</tt>
zipWith_mul :: forall r a. (Rounding r, Unbox a, RoundedRing_Vector Vector a) => Vector (Rounded r a) -> Vector (Rounded r a) -> Vector (Rounded r a)

-- | Equivalent to <tt><a>zipWith3</a> fusedMultiplyAdd</tt>
zipWith3_fusedMultiplyAdd :: forall r a. (Rounding r, Unbox a, RoundedRing_Vector Vector a) => Vector (Rounded r a) -> Vector (Rounded r a) -> Vector (Rounded r a) -> Vector (Rounded r a)

-- | Equivalent to <tt><a>zipWith</a> (/)</tt>
zipWith_div :: forall r a. (Rounding r, Unbox a, RoundedFractional_Vector Vector a) => Vector (Rounded r a) -> Vector (Rounded r a) -> Vector (Rounded r a)

-- | Equivalent to <tt><a>map</a> sqrt</tt>
map_sqrt :: forall r a. (Rounding r, Unbox a, RoundedSqrt_Vector Vector a) => Vector (Rounded r a) -> Vector (Rounded r a)
